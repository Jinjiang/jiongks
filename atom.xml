<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>囧克斯</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jiongks.name/"/>
  <updated>2020-04-27T12:29:56.000Z</updated>
  <id>https://jiongks.name/</id>
  
  <author>
    <name>勾三股四</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>中文格式化小工具 zhlint 及其开发心得</title>
    <link href="https://jiongks.name//blog/introducing-zhlint/"/>
    <id>https://jiongks.name//blog/introducing-zhlint/</id>
    <published>2020-04-26T03:53:59.000Z</published>
    <updated>2020-04-27T12:29:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>介绍要给小工具给大家：<strong><a href="https://github.com/Jinjiang/zhlint">zhlint</a></strong></p><p><img src="https://raw.githubusercontent.com/Jinjiang/zhlint/master/logo.svg" alt="zhlint logo"></p><p>这个工具可以帮助你快速格式化中文或中英混排的文本。比如常见的中英文之间要不要用空格、标点符号要用全角字符之类的。</p><p>看上去这工具似乎和自己的工作和职业关系不大，但其实也是有一定由来的。</p><h3 id="项目的由来"><a href="#项目的由来" class="headerlink" title="项目的由来"></a>项目的由来</h3><p>自己之前参与过一些 <a href="https://www.w3.org/html/ig/zh/wiki/%E7%BF%BB%E8%AF%91">W3C 规范的翻译工作</a>，这其中除了需要一定的词汇量、语法知识和表达技巧之外，最主要的部分应该就是格式了。因为大家对诸如空格、标点符号等细节的使用其实不太统一，这在团队协作的时候其实会变成问题，大家都花了一些不必要的时间在格式讨论和校对上。感觉这部分工作比较枯燥且机械，但又不得不做。只能花更多时间在上面。</p><p>后来因为接触 <a href="https://vuejs.org/">Vue.js</a> 的关系。这个项目在早期并没有太多人知道它，而且当时社区普遍比较迷信像 Google 这种大厂官方推出的技术方案，对“野生”项目都不是很有兴趣，所以我希望可以把这个项目介绍给更多人认识。结合我之前的翻译经验，我觉得翻译文档是一个比较好的途径，于是就发起了 <a href="https://github.com/vuejs/cn.vuejs.org/">Vue 中文文档</a>的翻译，结果没想到这件事一发不可收拾，我就不知不觉从 2014/2015 年做到了今天。随着 Vue 的不断发展，关注文档的人也越来越多，中间发生了很多故事，这些故事也让我自己逐步对翻译和中文格式的细节有了更多的认识。</p><p>真正触发我做这个项目的事情，是去年的一个翻译讨论：<a href="https://github.com/vuejs/cn.vuejs.org/issues/480">如何</a><a href="https://github.com/vuejs/cn.vuejs.org/issues/544">翻译</a> <a href="https://github.com/vuejs/cn.vuejs.org/issues/630">attribute</a> 和 <a href="https://github.com/vuejs/cn.vuejs.org/issues/646">property</a>。这个问题几乎从我接触技术翻译的第一天起就一直是个噩梦。我和周围的小伙伴尝试了各种译法，都不能让所有人满意，无奈之下通过刻意的区分和强化教育，把它们分别译成“特性”和“属性”。这个状态持续了很长一段时间，Vue 的文档也基本都是这么翻译的。直到去年的一段时间，我逐步意识到，也许这两个词不翻译会更好，索性直接保留英文原词，这样不会有歧义，同时随着整个社区的英文程度在提高，像这样的词不翻译大家应该也能顺畅的理解了，中英文混着读也逐渐可以接受了。所以就在 GitHub 开了个 <a href="https://github.com/vuejs/cn.vuejs.org/issues/895">issue</a>，同时也扩散到了 <a href="https://lists.w3.org/Archives/Public/public-chinese-web/2019Apr/0000.html">W3C Web 中文兴趣组</a>。没想到这次讨论大家的意见出奇的一致，几乎“全票通过”。看上去困扰我多年的问题终于要解开了……</p><p>然而在这之后，我意识到，如何对已经翻译好的大量文档做关键词批量替换并不是一件容易的事情——主要还是格式细节太多了。不能做简单粗暴的文本批量替换。</p><p>比如把“特性”换回“attribute”之后，如果“特性”一词的两边也都还是中文，那么“attribute”两边就都需要加一个空格，而如果是标点符号就不需要，而如果是英文，那理论上这个空格已经加过了。所以情况很多很复杂。你读到这里可能觉得那我们稍微加个正则表达式也许可以解决，那我会在告诉你，如果这个词的边上还可能有 HTML 标记或 Markdown 标记，那这个正则该如何写呢？或许也不那么容易了。</p><p>因此这个译法改动在去年就已经有定论了，但是实际上到今年上半年我才真正改好。原因是我觉得这次我不打算再靠蛮力去解决问题了，而打算通过工具来解决——这就是我做这个项目的由来和动机——没错我陆陆续续做了一年左右，最近终于做出一个比较文档的版本了，然后才完成了这次译法的替换。</p><p>另外一个促使我做这个工具的原因其实是我个人希望尝试一些语法分析之类的技术，因为觉得作为一个前端工程师，未来这个方向的可能性和空间比较大。如之前和很多人都聊到过的，现如今的前端框架全部都开始在编辑器这个环节大做文章。因为它可以帮助你突破一些 JS 语言的限制。所以大家武装到牙齿之后这部分是一定会碰的。我预测接下来这个趋势会从框架往上发展，逐步延申到前端工作的更多环节。做这个工具看上去似乎有那么一点可以积累到的知识和经验，于是就想先做个这个试试看。</p><a id="more"></a><h3 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h3><p>接下来回到 zhlint 这个工具，介绍一下我设计的基本用法：</p><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><ol><li>在安装 Node 和 Yarn 之后，运行 <code>yarn global add zhlint</code> 或 <code>npm install -g zhlint</code>。这样 zhlint 就安装好了。</li><li>在命令行里运行 zhlint，就可以启动这个工具并看到关于它的帮助信息。</li><li>如果想真正校验一个文本文件，可以运行 <code>zhlint &lt;filepath&gt;</code>，比如我们创建一个文件叫做 <code>foo.md</code>，其中的文本内容是 <code>中文English</code>。那么运行 <code>zhlint foo.md</code> 会收到一个错误提示，提醒你中英文之间应该有一个空格。</li><li>现在我们更进一步，运行 <code>zhlint foo.md --fix</code>，顾名思义这个命令会自动修复文件中的格式错误。所以运行之后文件 <code>foo.md</code> 内部的文本内容会变成 <code>中文 English</code>。</li><li>如果现在有一批文件都需要做格式校验，zhlint 还支持批量多文件匹配。比如 <code>zhlint src/*.md</code> 可以校验 <code>src</code> 目录下的所有 md 文件。同理也可以加 <code>--fix</code> 做批量自动修复。</li></ol><h4 id="常见格式问题"><a href="#常见格式问题" class="headerlink" title="常见格式问题"></a>常见格式问题</h4><ol><li>空格问题</li></ol><ul><li><code>中文English中文</code> -&gt; <code>中文 English 中文</code></li><li><code>中文 ， 中文</code> -&gt; <code>中文，中文</code></li><li><code>1+1=2</code> -&gt; <code>1 + 1 = 2</code></li></ul><ol start="2"><li>全角/半角问题</li></ol><p><code>中文, 中文.</code> -&gt; <code>中文，中文。</code></p><ol start="3"><li>特殊组合用法问题</li></ol><ul><li><code>Mr.</code> (不转换全角句号)</li><li><code>2020/01/02 01:20:30</code> (在描述时间和日期的时候冒号和斜杠两边没有空格)</li></ul><ol start="4"><li>特殊个例问题</li></ol><ul><li><code>33.30KB min+gzip</code> (这里的加号两边不会加空格，该 case 没有普遍规律)</li></ul><h3 id="研发过程和心得"><a href="#研发过程和心得" class="headerlink" title="研发过程和心得"></a>研发过程和心得</h3><p>现在回顾之前的研发过程，首先是做得比较懒散，陆陆续续一点一点做，其次是返工了无数次，发现哪里走不通了就推倒重来，所以经历了太长的时间。</p><h4 id="第一版-未完成-未发布"><a href="#第一版-未完成-未发布" class="headerlink" title="第一版 (未完成 + 未发布)"></a>第一版 (未完成 + 未发布)</h4><p>在最初的版本里，我想的比较简单，就只是把中文内容分为几个颗粒度去处理：char、token、full text。所以我当时只做了五件事：</p><ol><li>逐个字符分类识别 (全角字符、半角字符、标点符号、空格)</li><li>把字符连接成若干个 token 并分类识别 (中文、英文、标点符号)</li><li>实现一个基本的 token 遍历函数</li><li>利用这个 token 遍历函数指定校验规则并遍历处理 (比如发现一个中文和一个英文的 token 挨着，就强制塞一个空格进去)</li><li>把处理过后的 token 再重新连接起来，得出最终的处理结果</li></ol><p>大概的代码结构是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> checkCharType = <span class="function"><span class="params">char</span> =&gt;</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> parse = <span class="function"><span class="params">str</span> =&gt;</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> travel = <span class="function">(<span class="params">tokens, filter, handler</span>) =&gt;</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> lint = <span class="function">(<span class="params">str, options</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// parse options</span></span><br><span class="line">  <span class="comment">// travel and process tokens</span></span><br><span class="line">  <span class="comment">// join tokens</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我逐渐发现 lint 这个函数越写越大，逐渐失控。原因有这么几个：</p><ol><li>中文里对括号和引号的使用非常灵活，设计之初低估了它的难度和复杂度。比如：<code>我们需要 (先做一件事，然后再做一件事，最后再) 做一件事</code>。括号可以断在任意的地方，可以跨越多个句子，可以包含最前边或最后边的标点符号，也可以把它们留在外边，被截断的前后句子单独拿出来也未必是完整的。</li><li>有一些非常特殊的 case 需要绕过，比如括号可以用在英文的单复数变化中 (<code>minute(s)</code>)、单引号可以用在英文缩写中 (<code>doesn&#39;t</code>) 等等。再比如在描述时间和日期的时候，我们不太习惯在每个数字之间都加空格所以会省略空格 (<code>2020年1月1日</code> 而不是 <code>2020 年 1 月 1 日</code>)。</li></ol><p>这些都导致设计之初通过简单的线性 token 机制处理很难做好这件事。“Travel and process” 这部分的代码越来越臃肿。逐渐我意识到，这里需要更多的结构化设计。于是我停下来考虑了一段时间。</p><h4 id="第二版：部分重构"><a href="#第二版：部分重构" class="headerlink" title="第二版：部分重构"></a>第二版：部分重构</h4><p>之后我逐渐想到两个主意：</p><ol><li>第一版尝试把 token 从线性结构转变成树形结构，但这棵树并不是规范的树，尤其是括号，所以我把括号从树形结构中抽离了出来，改为记号 (mark)。记号不会影响树形结构本身，可以单独识别和处理。这有点类似 HTML 之于 text 的区别，也就是某种“超文本标记”。事后证明 mark 这个结构和思路对后续的功能研发还有很大帮助。</li><li>把需要 lint 的格式细节整理成一个一个独立的规则，然后轮流处理，这样庞大的“travel and process tokens”就有机会变成 <code>const rules = [...]; rules.reduce(processRule, str)</code>。这个思路其实我一开始想到过，但觉得把每条规则都抽象并独立出来是很有难度的，所以一直没有下定决心做。经过这次深思熟虑之后我鼓起勇气试了一下，看起来还是可行的，效果也还可以。</li></ol><p>于是我决定把之前的主分支退役，重新开启一个新的分支，开始以上述思路重构代码。</p><p>重构之后的处理流程更像是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// separated files</span></span><br><span class="line"><span class="keyword">const</span> rules = [</span><br><span class="line">  (token, index, group, matched, marks) =&gt; &#123;...&#125;,</span><br><span class="line">  (token, index, group, matched, marks) =&gt; &#123;...&#125;,</span><br><span class="line">  (token, index, group, matched, marks) =&gt; &#123;...&#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> checkCharType = <span class="function"><span class="params">char</span> =&gt;</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> parse = <span class="function"><span class="params">str</span> =&gt;</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> travel = <span class="function">(<span class="params">tokens, filter, handler</span>) =&gt;</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> processRule = <span class="function">(<span class="params">&#123; tokens, marks, ... &#125;, rule</span>) =&gt;</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> join = <span class="function">(<span class="params">tokens</span>) =&gt;</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> lint = <span class="function">(<span class="params">str, options</span>) =&gt;</span> &#123;...&#125;</span><br></pre></td></tr></table></figure><p>有了这个结构，我就可以更加专注在格式规则的定义和实现上了。随着工作的深入，我也逐渐加入了一些务实的功能和设计。</p><h4 id="支持-Markdown-HTML-格式"><a href="#支持-Markdown-HTML-格式" class="headerlink" title="支持 Markdown/HTML 格式"></a>支持 Markdown/HTML 格式</h4><p>截至目前，我们 lint 的假设性目标都是一个字符串——确切的说是单行字符串。但实际上我们需要处理的真实的文本内容是更复杂的。目前绝大多数待处理的文本内容都是 Markdown 格式，可能还夹带了一些 HTML 标记，而且是多行文本。</p><p>为了解决真实的问题，我稍微花了一些时间去了解如何解析 Markdown 语法。之前用到 Markdown 的地方基本都是从 Markdown 渲染出最终的 HTML 代码，但这次我们不太需要最终的 HTML 代码，而是 AST，也就是抽象语法树。最终我找到了一个叫做 <a href="https://unifiedjs.com/">unified.js</a> 的库，它可以把各种格式的文本内容解析成为相应格式的 AST。其中 <a href="https://remark.js.org/">remark.js</a> 就是在这个库的基础上用来解析 Markdown 语法的，其 AST 格式为 <a href="https://github.com/syntax-tree/mdast">mdast</a>。大致的用法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unified = <span class="built_in">require</span>(<span class="string">&#x27;unified&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> markdown = <span class="built_in">require</span>(<span class="string">&#x27;remark-parse&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> frontmatter = <span class="built_in">require</span>(<span class="string">&#x27;remark-frontmatter&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// the content</span></span><br><span class="line"><span class="keyword">const</span> content = <span class="string">&#x27;...&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ast = unified().use(markdown).use(frontmatter).parse(content)</span><br><span class="line"></span><br><span class="line"><span class="comment">// process the Markdown AST</span></span><br></pre></td></tr></table></figure><p>接下来就是根据 mdast 庖丁解牛的时刻了。经过研究 mdast 的文档，我发现在 Markdown 语法里，所有的语法节点都可以简单粗暴的区分为两大类：inline 和 block。而 zhlint 要处理的其实就是找出所有不能再拆解的 block，然后把其中的 inline 节点在 zhlint 中标注为我们之前提到过的 mark 类 token。当然其中 inline 节点还要再分为两类：一类是包含文本内容的 (例如加粗、斜体、链接等)，需要继续 lint 处理；一类不包含 (例如图片)，需要原文保留。对于代码片段，我们从自然语言分析的角度认为它不是文本内容，所以也算后者。更妙的是其实在 Markdown 的 parser 里其实是包含了对 HTML 标记的解析的，所以我们不需要额外引入 HTML parser 就可以完成对 HTML 标记的支持。</p><p>源代码中大致的语法节点分类如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不能再拆解的 block</span></span><br><span class="line"><span class="keyword">const</span> blockTypes = [</span><br><span class="line">  <span class="string">&#x27;paragraph&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;heading&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;table-cell&#x27;</span></span><br><span class="line">]</span><br><span class="line"><span class="comment">// 包含文本的 inline</span></span><br><span class="line"><span class="keyword">const</span> inlineMarkTypes = [</span><br><span class="line">  <span class="string">&#x27;emphasis&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;strong&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;delete&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;footnote&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;link&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;linkReference&#x27;</span></span><br><span class="line">]</span><br><span class="line"><span class="comment">// 不包含文本的 inline</span></span><br><span class="line"><span class="keyword">const</span> rawMarkTypes = [</span><br><span class="line">  <span class="string">&#x27;inlineCode&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;break&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;image&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;imageReference&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;footnoteReference&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;html&#x27;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这样我们就可以先把所有的文本中不可拆解的 block 找出来，同时对这些 block 内部出现的超文本做好 mark 标记，然后带着这些 mark 逐个 lint，最后再把这些结果填入之前的 block 所在的位置。大致思路如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> blocks = parseMarkdown(str).blocks</span><br><span class="line"><span class="keyword">const</span> blockResults = blocks.map(lintBlock)</span><br><span class="line"><span class="keyword">const</span> result = replaceBlocks(str, blocksResult.map(</span><br><span class="line">  <span class="comment">// 意在强调主要处理的信息是处理后的结果和之前所在字符串中的位置</span></span><br><span class="line">  (&#123; value, position &#125;) =&gt; (&#123; value, position &#125;)</span><br><span class="line">))</span><br></pre></td></tr></table></figure><p>当然要想把 Markdown/HTML 语法处理好这还不算完，因为相应的 lint 规则也变得更加复杂了。举个例子，当我们处理空格的时候，希望空格始终出现在 inline mark 的外侧 (<code>中文 [English](a-link-here) 中文</code> 而不是 <code>中文[ English ](a-link-here)中文</code>)。所以对已有规则处理上的复杂度相当于是指数级增长了一倍。而且实际上到最后还需要特别添加一些针对 Markdown/HTML 语法的规则。这里我其实在过程中反复做了各种尝试和搭配组合，才变成了现在的样子。现在的规则已经相对比较稳定了。同时我也在实现类似的规则过程中逐步积累了很多 util functions。所以拜托了一些低级别的重复性问题之后，整个研发过程越往后其实会变得越清晰越简单。</p><h4 id="特殊情况处理"><a href="#特殊情况处理" class="headerlink" title="特殊情况处理"></a>特殊情况处理</h4><p>在设计和实现 lint 规则的过程中，自己也积累了一些心得，总体上所有的 lint 规则或选项被分为了四部分，分别对应四种需求：</p><ul><li>基本规则：对空格、标点符号、超文本标记用法的基本定义。这部分规则会抽象成一个 rule。</li><li>特殊 case 规则：需要打破上述基本规则，但同时具有一定的领域普遍性，比如时间日期的格式、数学表达式、英文中的单引号缩写等。这部分规则也会抽象成一个 rule，但会在很小范围内做定向分析。</li><li>忽略个别情况：针对具体文本的具体特殊片段，采取保留原文格式的措施，比如加号前后通常是需要空格的，但在具体到 <code>min+gzip</code> 的时候，之间没有空格。针对这部分规则我们提供了一种注释语法，可以被 zhlint 识别，从而在 <code>join</code> 的时候跳过。<ul><li>例如上述例子，我们可以在整个被处理的文本内容的任意地方加入注释 <code>&lt;!-- zhlint ignore: min+gzip --&gt;</code>。</li><li>除此之外，我们还支持了更复杂的通配规则，这里主要参考了一个个人觉得非常棒的 W3C 新提案：<a href="https://github.com/WICG/ScrollToTextFragment">Scroll to Text Fragment</a>。我们引入了类似的语法 <code>[prefix-,]textStart[,textEnd][,-suffix]</code>。这样用户就可以更灵活的使用这一功能。</li></ul></li><li><a href="https://hexo.io/docs/tag-plugins">Hexo tag plugin</a>：在解析的过程中忽略所有 Hexo tag plugin 语法。这个更特殊一点，实际上是针对 Vue 的中文文档加上的。<ul><li>因为做这件事情意味着需要多个 parser 逐个调用处理，因此我在之前的 <code>parseMarkdown</code> 机制的基础上加入了 hyper parser chain 的机制，每段文本在真正运行每条 lint 规则之前，都会链式运行所有的 hyper parser。最终包括了 Markdown 解析、Hexo tag plugin 解析、还有被忽略的个别情况的注释解析。</li></ul></li></ul><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>这次研发过程中，我比较早，也比较严格的实践了测试驱动开发。基于 <a href="https://jestjs.io/">Jest</a> 写了很多用例，通过这些用例把工具的行为“卡死”，这样当后期引入更多复杂度的时候 (比如决定重构第二版的时候、或决定支持 Markdown 格式之后)，可以通过锁住测试用例进行大胆的重构和尝试，并且在重构的时候一旦发现一些之前没有覆盖到的 edge case，就立刻补充进去，然后重构至这个 case 跑通为止再继续。久而久之整套测试用例也越来越见状。总体下来还是受益匪浅的，帮自己省了很多时间和脑细胞——上一次有这种感觉的项目是 Weex JS runtime 第一版。如一些朋友知道的，当时我们只有 2 个月时间，要从零写一个 JS 框架用在双十一移动主会场，所以除了测试用例我当时谁也没法相信。</p><h4 id="最终收尾"><a href="#最终收尾" class="headerlink" title="最终收尾"></a>最终收尾</h4><p>完成上述核心功能之后，差不多已经过去一年时间了，最后的一些工作留给了下述这些“外包装”。</p><ul><li>支持 CLI 命令</li><li>错误报告</li><li>打印日志</li><li>构建 standalone 版本</li><li>发布到 npm</li></ul><p>值得一提的是自己在打印日志的时候，想实现类似 TSC 或 Vue 3.0 模板编译的错误打印格式，即打印出错误所在的那一行代码，并且在再下一行的出错位置放一个小尖角字符 (<code>^</code>) 以方便用户定位问题，例如这是 Vue 3.0 模板编译里的效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2  |    &lt;template key&#x3D;\\&quot;one\\&quot;&gt;&lt;&#x2F;template&gt;</span><br><span class="line">3  |    &lt;ul&gt;</span><br><span class="line">4  |      &lt;li v-for&#x3D;\\&quot;foobar\\&quot;&gt;hi&lt;&#x2F;li&gt;</span><br><span class="line">   |          ^^^^^^^^^^^^^^</span><br><span class="line">5  |    &lt;&#x2F;ul&gt;</span><br><span class="line">6  |    &lt;template key&#x3D;\\&quot;two\\&quot;&gt;&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><p>但问题来到 zhlint 之后遇到了一些比较特别的问题：</p><ol><li>zhlint 处理的文本多半是自然语言，每个段落的字数长短不一，所以大概率在打印的时候会折行 (相对来说代码书写长期的最佳实践是每行少于 80 个字符，所以这个问题并不明显)。设想一下如果被定位的字符在一大段话的正中间，那么再下一行的小尖角字符已经完全失去了辅助定位的作用。</li><li>zhlint 处理的多半是中文文本，所以这产生了另外一个问题，中英文混排的时候字符是不等宽的。所以小尖角字符之前的空格数很难算准。</li></ol><p>为此我采取了一种不太一样的定位展示效果：</p><ol><li>不会打印一整行文本，只会取目标字符前后一段距离的字符串片段 (如前后各 20 个字符)，然后在其片段两边加入省略号。</li><li>引入日志着色包 <code>chalk</code>，这样就可以为日志上色。</li><li>把小尖叫符号同一行之前的空格用相同的字符串片段在此字符之前截断的部分替代，并同时设置背景色和文本色为同一个颜色 (黑色)。</li></ol><p>所以最终看到的效果，如果把特别的着色去掉的话，看到的效果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">自动在中文和English之间加入空格</span><br><span class="line">自动在中文和^</span><br></pre></td></tr></table></figure><p>但实际效果中第二行的“自动在中文和”是看不到的，只会看到一条黑色矩形。运气好的话，如果你的命令行背景也是黑色的，那么就完全看不出差别了。</p><p><img src="https://github.com/Jinjiang/zhlint/raw/master/screenshot-cli.png" alt=""></p><p>另外一个测试的时候的小技巧，如果你不希望日志打印把测试报告搞得乱七八糟，可以结合 Jest 的环境变量判断 + 自定义 Console 对象把日志打印到别的流，然后做二次处理或直接抛掉，代码类似：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stdout = process.stdout</span><br><span class="line"><span class="keyword">let</span> stderr = process.stderr</span><br><span class="line"><span class="keyword">let</span> defaultLogger = <span class="built_in">console</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Jest env</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">global</span>.__DEV__) &#123;</span><br><span class="line">  <span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> &#123; Console &#125; = <span class="built_in">require</span>(<span class="string">&#x27;console&#x27;</span>)</span><br><span class="line">  stdout = fs.createWriteStream(<span class="string">&#x27;./stdout.log&#x27;</span>, &#123; <span class="attr">encoding</span>: <span class="string">&#x27;utf-8&#x27;</span> &#125;)</span><br><span class="line">  stderr = fs.createWriteStream(<span class="string">&#x27;./stderr.log&#x27;</span>, &#123; <span class="attr">encoding</span>: <span class="string">&#x27;utf-8&#x27;</span> &#125;)</span><br><span class="line">  defaultLogger = <span class="keyword">new</span> Console(&#123; stdout, stderr &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// usage</span></span><br><span class="line">defaultLogger.log(...)</span><br></pre></td></tr></table></figure><p>最后推荐几个我用到的 npm 包，如果大家想做类似的事情，可以做个参考 (当然如果你有更好的推荐也可以)：</p><ul><li><a href="https://www.npmjs.com/package/chalk">chalk</a>：着色打印日志</li><li><a href="https://www.npmjs.com/package/glob">glob</a>：批量匹配文件，支持简单的通配符语法，用于批量 lint 文本文件</li><li><a href="https://www.npmjs.com/package/minimist">minimist</a>：自动解析 CLI 的命令参数</li></ul><h3 id="zhlint-的使用情况"><a href="#zhlint-的使用情况" class="headerlink" title="zhlint 的使用情况"></a>zhlint 的使用情况</h3><p>目前 zhlint 已经集成到了 Vue 的中文文档项目中。通过<a href="https://github.com/vuejs/cn.vuejs.org/pull/1079">简单的 CI 配置</a>，就可以轻松做到为每个 PR 自动 lint 并返回处理结果。</p><p>有了这个工具之后，我们就可以比较没有心智负担地批量替换文本了，替换之后运行一遍类似 <code>zhlint src/*.md --fix</code> 的命令，即可把因批量替换产生的格式问题全部修复。</p><p>然后，我就立刻完成了<a href="https://github.com/vuejs/cn.vuejs.org/pull/1081">对 attribute 和 property 的替换</a>……</p><p>所以“为了批量替换两个单词的译法，我花了差不多一年的时间” (这原本是我设想的这篇文章标题党版本的标题)</p><p>之后我们在 Vue 文档中又陆续遇到了讨论 <a href="https://github.com/vuejs/cn.vuejs.org/issues/1049">mutation</a>、<a href="https://github.com/vuejs/cn.vuejs.org/issues/1084">ref</a> 译法的问题。产生的相应改动也都可以基于 zhlint 很容易的得以实现。</p><p>有趣的是，在我在<a href="https://www.weibo.com/1712131295/IDJsakzFq">微博</a>和 <a href="https://twitter.com/zhaojinjiang/status/1250828817112825856">Twitter</a> 简单分享了这个小工具之后，也有人留言说其实写博客的时候这个工具也非常有用。或许这是 zhlint 可能的更多用途吧😉！</p><h3 id="最后的回顾"><a href="#最后的回顾" class="headerlink" title="最后的回顾"></a>最后的回顾</h3><p>最后，关于心得体会和收获，我觉得有这么几个：</p><ul><li>首先觉得写 parser 和 linter 是个蛮有趣的事情，有很多不一样的体验，尤其对于前端工程师来说，既熟悉 (处理字符串) 又陌生 (没有 UI，生吃字符串)。未来对 ast 相关的技术会持续自我投资。</li><li>测试驱动 FTW。</li><li>越来越少有机会真正自己从 0 到 1 做些东西出来了，很珍惜这次机会和类似的工作。</li><li>如果发现不对劲，及时停下来或调头。不必也不能太过纠结。在功能成型之前，永远只为最终的理想形态而努力。</li><li>要耐得住性子，这次做这个小工具很考验自己的性格。虽然业余时间已经很有限了，但是持之以恒，就是胜利。</li></ul><p>另外 zhlint 其实还没有做完，我已经想到了更多的 feature 和改进点，其实也已知了不少不理想不完美不够好的地方。所以会继续做下去。</p><p>以上</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍要给小工具给大家：&lt;strong&gt;&lt;a href=&quot;https://github.com/Jinjiang/zhlint&quot;&gt;zhlint&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Jinjiang/zhlint/master/logo.svg&quot; alt=&quot;zhlint logo&quot;&gt;&lt;/p&gt;
&lt;p&gt;这个工具可以帮助你快速格式化中文或中英混排的文本。比如常见的中英文之间要不要用空格、标点符号要用全角字符之类的。&lt;/p&gt;
&lt;p&gt;看上去这工具似乎和自己的工作和职业关系不大，但其实也是有一定由来的。&lt;/p&gt;
&lt;h3 id=&quot;项目的由来&quot;&gt;&lt;a href=&quot;#项目的由来&quot; class=&quot;headerlink&quot; title=&quot;项目的由来&quot;&gt;&lt;/a&gt;项目的由来&lt;/h3&gt;&lt;p&gt;自己之前参与过一些 &lt;a href=&quot;https://www.w3.org/html/ig/zh/wiki/%E7%BF%BB%E8%AF%91&quot;&gt;W3C 规范的翻译工作&lt;/a&gt;，这其中除了需要一定的词汇量、语法知识和表达技巧之外，最主要的部分应该就是格式了。因为大家对诸如空格、标点符号等细节的使用其实不太统一，这在团队协作的时候其实会变成问题，大家都花了一些不必要的时间在格式讨论和校对上。感觉这部分工作比较枯燥且机械，但又不得不做。只能花更多时间在上面。&lt;/p&gt;
&lt;p&gt;后来因为接触 &lt;a href=&quot;https://vuejs.org/&quot;&gt;Vue.js&lt;/a&gt; 的关系。这个项目在早期并没有太多人知道它，而且当时社区普遍比较迷信像 Google 这种大厂官方推出的技术方案，对“野生”项目都不是很有兴趣，所以我希望可以把这个项目介绍给更多人认识。结合我之前的翻译经验，我觉得翻译文档是一个比较好的途径，于是就发起了 &lt;a href=&quot;https://github.com/vuejs/cn.vuejs.org/&quot;&gt;Vue 中文文档&lt;/a&gt;的翻译，结果没想到这件事一发不可收拾，我就不知不觉从 2014/2015 年做到了今天。随着 Vue 的不断发展，关注文档的人也越来越多，中间发生了很多故事，这些故事也让我自己逐步对翻译和中文格式的细节有了更多的认识。&lt;/p&gt;
&lt;p&gt;真正触发我做这个项目的事情，是去年的一个翻译讨论：&lt;a href=&quot;https://github.com/vuejs/cn.vuejs.org/issues/480&quot;&gt;如何&lt;/a&gt;&lt;a href=&quot;https://github.com/vuejs/cn.vuejs.org/issues/544&quot;&gt;翻译&lt;/a&gt; &lt;a href=&quot;https://github.com/vuejs/cn.vuejs.org/issues/630&quot;&gt;attribute&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/vuejs/cn.vuejs.org/issues/646&quot;&gt;property&lt;/a&gt;。这个问题几乎从我接触技术翻译的第一天起就一直是个噩梦。我和周围的小伙伴尝试了各种译法，都不能让所有人满意，无奈之下通过刻意的区分和强化教育，把它们分别译成“特性”和“属性”。这个状态持续了很长一段时间，Vue 的文档也基本都是这么翻译的。直到去年的一段时间，我逐步意识到，也许这两个词不翻译会更好，索性直接保留英文原词，这样不会有歧义，同时随着整个社区的英文程度在提高，像这样的词不翻译大家应该也能顺畅的理解了，中英文混着读也逐渐可以接受了。所以就在 GitHub 开了个 &lt;a href=&quot;https://github.com/vuejs/cn.vuejs.org/issues/895&quot;&gt;issue&lt;/a&gt;，同时也扩散到了 &lt;a href=&quot;https://lists.w3.org/Archives/Public/public-chinese-web/2019Apr/0000.html&quot;&gt;W3C Web 中文兴趣组&lt;/a&gt;。没想到这次讨论大家的意见出奇的一致，几乎“全票通过”。看上去困扰我多年的问题终于要解开了……&lt;/p&gt;
&lt;p&gt;然而在这之后，我意识到，如何对已经翻译好的大量文档做关键词批量替换并不是一件容易的事情——主要还是格式细节太多了。不能做简单粗暴的文本批量替换。&lt;/p&gt;
&lt;p&gt;比如把“特性”换回“attribute”之后，如果“特性”一词的两边也都还是中文，那么“attribute”两边就都需要加一个空格，而如果是标点符号就不需要，而如果是英文，那理论上这个空格已经加过了。所以情况很多很复杂。你读到这里可能觉得那我们稍微加个正则表达式也许可以解决，那我会在告诉你，如果这个词的边上还可能有 HTML 标记或 Markdown 标记，那这个正则该如何写呢？或许也不那么容易了。&lt;/p&gt;
&lt;p&gt;因此这个译法改动在去年就已经有定论了，但是实际上到今年上半年我才真正改好。原因是我觉得这次我不打算再靠蛮力去解决问题了，而打算通过工具来解决——这就是我做这个项目的由来和动机——没错我陆陆续续做了一年左右，最近终于做出一个比较文档的版本了，然后才完成了这次译法的替换。&lt;/p&gt;
&lt;p&gt;另外一个促使我做这个工具的原因其实是我个人希望尝试一些语法分析之类的技术，因为觉得作为一个前端工程师，未来这个方向的可能性和空间比较大。如之前和很多人都聊到过的，现如今的前端框架全部都开始在编辑器这个环节大做文章。因为它可以帮助你突破一些 JS 语言的限制。所以大家武装到牙齿之后这部分是一定会碰的。我预测接下来这个趋势会从框架往上发展，逐步延申到前端工作的更多环节。做这个工具看上去似乎有那么一点可以积累到的知识和经验，于是就想先做个这个试试看。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Chinese" scheme="https://jiongks.name/tags/Chinese/"/>
    
      <category term="lint" scheme="https://jiongks.name/tags/lint/"/>
    
      <category term="tool" scheme="https://jiongks.name/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>vue-mark-display：用 markdown 语法轻松撰写幻灯片</title>
    <link href="https://jiongks.name//blog/introducing-vue-mark-display/"/>
    <id>https://jiongks.name//blog/introducing-vue-mark-display/</id>
    <published>2019-04-04T23:21:27.000Z</published>
    <updated>2021-02-06T14:42:25.197Z</updated>
    
    <content type="html"><![CDATA[<p>为大家介绍一个刚刚开源，但其实自己已经使用超过 5 年的小工具：<code>vue-mark-display</code>。你可以用它把 <a href="https://commonmark.org/help/">markdown</a> 格式的文本转换成幻灯片并在浏览器中播放和控制。</p><h3 id="开发背景"><a href="#开发背景" class="headerlink" title="开发背景"></a>开发背景</h3><p>我自己工作中经常需要准备各式各样的幻灯片，所以逐渐觉得用 PowerPoint 或 Keynote 来做幻灯演示略微显得有些笨重。这体现在板式和样式设计、文件大小、打开、编辑和播放的方式等很多方面。加上我从事的就是前端开发的工作，对语义化的信息格式非常敏感，深刻的认为，那些你表面上想编辑的“样式”其实是信息的“类型”+“配套的样式”罢了。所以决定用 markdown 外加自己扩展的一些小功能，来撰写幻灯片，并研发了相应的工具，也就是最近开源的 <code>vue-mark-display</code>。</p><p>最早这个工具是用 vue v0.10 写的，当时源代码里还有像 <code>v-attr</code>, <code>v-repeat</code>, <code>v-transition</code> 这样的“古董级”语法，而且还在依赖 Zepto。最近准备开源这个项目的时候，我也基于最新的前端知识和技能进行了重构。所以大家看到的是比较新的版本。</p><p>其实在此之前，我也写过很多类似的小工具了，但都没有坚持使用很久，这次开源的 <code>vue-mark-display</code> 我差不多持续使用了 5 年。经历了差不多这 5 年时间，准备过了无数的幻灯片和公开演讲，我想说基于 markdown 以及这些小功能撰写幻灯片真的很酷。如果你也有兴趣试一试用 markdown 为主体来撰写自己的幻灯片，那么不妨了解并体验一下 <code>vue-mark-display</code>。</p><p><strong>另外，事实上，如果只是想使用它，你是不需要学习任何关于 Vue 的知识的</strong> —— <strong>文章最后会提供一个不需要 Vue 知识的开箱即用的办法</strong> —— 所以它也对 React、Angular 等社区的同学友好 —— 只要你会写 markdown 和简单的 HTML5 代码，你就可以使用 <code>vue-mark-display</code> 制作出非常精美的幻灯片。</p><a id="more"></a><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>首先，我们在 markdown 语法的基础上做了一个扩展：通过 <code>----</code> 分割线把一整篇 markdown 文档划分成为若干张幻灯片。</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 这里是第一页</span></span><br><span class="line"></span><br><span class="line">以及一些基本的自我介绍</span><br><span class="line"></span><br><span class="line">----</span><br><span class="line"></span><br><span class="line"><span class="section">### 这里是第二页</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 这里有内容</span><br><span class="line"><span class="bullet">-</span> 这里有内容</span><br><span class="line"><span class="bullet">-</span> 这里有内容</span><br><span class="line"></span><br><span class="line">----</span><br><span class="line"></span><br><span class="line">没了，讲完了</span><br><span class="line"></span><br><span class="line"><span class="strong">__谢谢__</span></span><br></pre></td></tr></table></figure><p>例如上面的例子就会被生成为三张幻灯片。</p><iframe src="https://codesandbox.io/embed/moxv1k071y?fontsize=14&module=%2Fsrc%2FApp.vue" title="Vue Mark Display Demo 1" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe><p>这样你就可以利用 markdown 支持的 h1 - h6 标题、列表、表格、图片、链接、加粗等格式加分页符用极快的速度写出幻灯片了。</p><p>通常情况下，你再为自己的幻灯片设置一套全局的 CSS 样式并固化下来成为你的样式风格，基本就可以拿来演示了。以下是我自己喜欢的样式风格：</p><iframe src="https://codesandbox.io/embed/61jorw0703?fontsize=14&module=%2Fsrc%2FApp.vue" title="Vue Mark Display Demo 2" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe><h4 id="自定义样式"><a href="#自定义样式" class="headerlink" title="自定义样式"></a>自定义样式</h4><p>在这个基础上，我们对 markdown 格式做了一点点进一步的扩展 —— 通过在每一页幻灯片开头撰写 html 注释来设置这页幻灯片的特殊样式。</p><p>比如我们为第二页幻灯片换一个不一样的背景，同时正文文字颜色变成白色：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 这里是第一页</span></span><br><span class="line"></span><br><span class="line">以及一些基本的自我介绍</span><br><span class="line"></span><br><span class="line">----</span><br><span class="line"></span><br><span class="line">&lt;!-- style: background: #4fc08d; color: white; --&gt;</span><br><span class="line"></span><br><span class="line"><span class="section">### 这里是第二页</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 这里有内容</span><br><span class="line"><span class="bullet">-</span> 这里有内容</span><br><span class="line"><span class="bullet">-</span> 这里有内容</span><br><span class="line"></span><br><span class="line">----</span><br><span class="line"></span><br><span class="line">没了，讲完了</span><br><span class="line"></span><br><span class="line"><span class="strong">__谢谢__</span></span><br></pre></td></tr></table></figure><p>现在翻到第二页看看，背景和文字的颜色就已经改变了</p><iframe src="https://codesandbox.io/embed/n734wvx92m?fontsize=14&module=%2Fsrc%2FApp.vue" title="Vue Mark Display Demo 3" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe><p>当然在 markdown 中你也可以撰写任意 HTML5 代码，比如嵌入一段 HTML 甚至全局有效的 <code>&lt;style&gt;</code> 标签，都可以被解析：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 这里是第一页</span></span><br><span class="line"></span><br><span class="line">以及一些基本的自我介绍</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;notification&quot;</span>&gt;</span></span>Welcome!<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">----</span><br><span class="line"></span><br><span class="line">&lt;!-- style: background: #4fc08d; color: white; --&gt;</span><br><span class="line"></span><br><span class="line"><span class="section">### 这里是第二页</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 这里有内容</span><br><span class="line"><span class="bullet">-</span> 这里有内容</span><br><span class="line"><span class="bullet">-</span> 这里有内容</span><br><span class="line"></span><br><span class="line">----</span><br><span class="line"></span><br><span class="line">没了，讲完了</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;notification&quot;</span>&gt;</span></span>Thanks!<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span></span><br><span class="line">.notification &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 20px;</span><br><span class="line">  right: 20px;</span><br><span class="line">  border-radius: 3px;</span><br><span class="line">  padding: 0.25em 1em;</span><br><span class="line">  background-color: yellow;</span><br><span class="line">  color: #666;</span><br><span class="line">&#125;</span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure><iframe src="https://codesandbox.io/embed/1z941rj65l?fontsize=14&module=%2Fsrc%2FApp.vue" title="Vue Mark Display Demo 4" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe><h4 id="其它自定义选项"><a href="#其它自定义选项" class="headerlink" title="其它自定义选项"></a>其它自定义选项</h4><p><code>vue-mark-display</code> 还提供了一些方便的 prop 配置项和 event 组件事件，如：</p><ul><li><code>@setTitle(&#123; title &#125;)</code> 方便从组件外部获取当前幻灯片的主标题，也就是第一页幻灯片的第一行文字，你可以用这个事件来设置 <code>document.title</code></li><li><code>autoFontSize</code> 根据屏幕大小自动调节默认字号，这个字号是根据自己的演示经验设置的。保证不论屏幕大小，一页幻灯片可以放下的字数是相对稳定的，这样就基本杜绝了因为演示现场屏幕分辨率不一致而导致的适配问题。当然你如果对这个默认的适配结果不满意，也可以自己手动设置组件的 <code>font-size</code> 样式。</li><li><code>supportPreview</code> 可以在点击链接的时候，按住键盘上的 <kbd>Alt</kbd> 键，这样链接会从当前屏幕的一个 <code>&lt;iframe&gt;</code> 打开，并悬浮在屏幕上方，同时右上角有个关闭按钮可以将其关掉。如果你希望整个幻灯演示过程不被中途访问链接而打断，相信这个功能你会非常喜欢。</li><li>还有一些选项包括：<code>urlHashCtrl</code> 能自动把当前页码和网页的 URL hash 对应、<code>keyboardCtrl</code> 可以支持默认键盘左右键翻页、<code>autoBlankTarget</code> 所有链接都默认在新标签打开、<code>baseUrl</code> 能将链接和图片的相对路径改成你自己的网站等。</li></ul><p>同时 <code>vue-mark-display</code> 还可以方面得利用第三方手势库支持触摸屏的左右滑动翻页。</p><p>上述比较完整的用例可以看这里：</p><iframe src="https://codesandbox.io/embed/300xq1mlkp?fontsize=14&module=%2Fsrc%2FApp.vue" title="Vue Mark Display Demo 5" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe><h3 id="One-More-Thing"><a href="#One-More-Thing" class="headerlink" title="One More Thing"></a>One More Thing</h3><p><code>vue-mark-display</code> 还支持直接导出成为 PDF 格式文件。因为我们的幻灯片有可能通过各式各样的方式进行传播：有可能是一个链接，也可能是一个文件。所以 <code>vue-mark-display</code> 利用 W3C 的 CSS Page Media 相关规范满足了这一需求，你只需要简单的打开浏览器的打印对话框，然后选择导出成为 PDF，就可以轻松的把自己的幻灯片发到钉钉好友、微信群、邮件附件等各个地方。</p><p><img src="https://github.com/Jinjiang/vue-mark-display/raw/master/pdf.png" alt=""></p><h3 id="最后想说-vue-mark-display-已经开源了"><a href="#最后想说-vue-mark-display-已经开源了" class="headerlink" title="最后想说 vue-mark-display 已经开源了"></a>最后想说 <code>vue-mark-display</code> 已经开源了</h3><p>欢迎大家试用并提出宝贵的意见，如能一同参与建设和维护，我会更加感激。</p><ul><li>Homepage: <a href="https://jinjiang.github.io/vue-mark-display/">https://jinjiang.github.io/vue-mark-display/</a></li><li>GitHub：<a href="https://github.com/jinjiang/vue-mark-display">https://github.com/jinjiang/vue-mark-display</a></li><li>npm: <a href="https://www.npmjs.com/package/vue-mark-display">https://www.npmjs.com/package/vue-mark-display</a></li></ul><p>同时我也把自己最近在社区分享过的幻灯片全部整理到了这个地址：</p><p><a href="https://jinjiang.github.io/slides/">https://jinjiang.github.io/slides/</a></p><p>接下里这个项目还有一些规划中的特性会逐步实现并发布，尽请关注。</p><h3 id="最后的最后"><a href="#最后的最后" class="headerlink" title="最后的最后"></a>最后的最后</h3><p><strong>如果你不想学 Vue，希望开箱即用，直接把 markdown 导出成在线幻灯片：</strong></p><p>来用 <code>mark2slides</code> 吧，一键导出！</p><p><a href="https://www.npmjs.com/package/mark2slides">https://www.npmjs.com/package/mark2slides</a></p><p>用法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --global mark2slides</span><br><span class="line">m2s my-slides.md</span><br></pre></td></tr></table></figure><p>然后去 <code>dist</code> 目录开启一个 web server：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> dist</span><br><span class="line">npx serve</span><br></pre></td></tr></table></figure><p>打开 <code>http://localhost:5000/</code>，完毕。</p><p>不过这个工具非常初期，还请大家多多提意见，接下来我也会逐步为这个工具增加更多贴心的功能。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为大家介绍一个刚刚开源，但其实自己已经使用超过 5 年的小工具：&lt;code&gt;vue-mark-display&lt;/code&gt;。你可以用它把 &lt;a href=&quot;https://commonmark.org/help/&quot;&gt;markdown&lt;/a&gt; 格式的文本转换成幻灯片并在浏览器中播放和控制。&lt;/p&gt;
&lt;h3 id=&quot;开发背景&quot;&gt;&lt;a href=&quot;#开发背景&quot; class=&quot;headerlink&quot; title=&quot;开发背景&quot;&gt;&lt;/a&gt;开发背景&lt;/h3&gt;&lt;p&gt;我自己工作中经常需要准备各式各样的幻灯片，所以逐渐觉得用 PowerPoint 或 Keynote 来做幻灯演示略微显得有些笨重。这体现在板式和样式设计、文件大小、打开、编辑和播放的方式等很多方面。加上我从事的就是前端开发的工作，对语义化的信息格式非常敏感，深刻的认为，那些你表面上想编辑的“样式”其实是信息的“类型”+“配套的样式”罢了。所以决定用 markdown 外加自己扩展的一些小功能，来撰写幻灯片，并研发了相应的工具，也就是最近开源的 &lt;code&gt;vue-mark-display&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;最早这个工具是用 vue v0.10 写的，当时源代码里还有像 &lt;code&gt;v-attr&lt;/code&gt;, &lt;code&gt;v-repeat&lt;/code&gt;, &lt;code&gt;v-transition&lt;/code&gt; 这样的“古董级”语法，而且还在依赖 Zepto。最近准备开源这个项目的时候，我也基于最新的前端知识和技能进行了重构。所以大家看到的是比较新的版本。&lt;/p&gt;
&lt;p&gt;其实在此之前，我也写过很多类似的小工具了，但都没有坚持使用很久，这次开源的 &lt;code&gt;vue-mark-display&lt;/code&gt; 我差不多持续使用了 5 年。经历了差不多这 5 年时间，准备过了无数的幻灯片和公开演讲，我想说基于 markdown 以及这些小功能撰写幻灯片真的很酷。如果你也有兴趣试一试用 markdown 为主体来撰写自己的幻灯片，那么不妨了解并体验一下 &lt;code&gt;vue-mark-display&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;另外，事实上，如果只是想使用它，你是不需要学习任何关于 Vue 的知识的&lt;/strong&gt; —— &lt;strong&gt;文章最后会提供一个不需要 Vue 知识的开箱即用的办法&lt;/strong&gt; —— 所以它也对 React、Angular 等社区的同学友好 —— 只要你会写 markdown 和简单的 HTML5 代码，你就可以使用 &lt;code&gt;vue-mark-display&lt;/code&gt; 制作出非常精美的幻灯片。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>我对技术会议的一些看法</title>
    <link href="https://jiongks.name//blog/thoughts-about-tech-conf/"/>
    <id>https://jiongks.name//blog/thoughts-about-tech-conf/</id>
    <published>2018-12-07T15:03:37.000Z</published>
    <updated>2021-02-06T14:42:25.201Z</updated>
    
    <content type="html"><![CDATA[<p>如题，今年陆续参加了一些技术会议，有些新的感触，尤其是今年第一次尝试多参加了一些境外的会议，有在 <a href="https://www.webconf.asia">HK</a> 的，有在 <a href="https://modernweb.tw/2018/">TW</a> 的，有在 <a href="https://vuefes.jp">JP</a> 的，感受很不一样，当然也参加了年初的厦门 CSSConfCN 和刚结束的 VueConfCN。另外网上越来越多人在讨论或是质疑参加技术会议到底有什么意义、好的技术会议应该是什么样子的，我也以写这篇博客的方式参与一下。</p><a id="more"></a><h3 id="会议的意义"><a href="#会议的意义" class="headerlink" title="会议的意义"></a>会议的意义</h3><p>我发现越来越多人讨论说会议里的内容很多都不是独家的，会后还会把幻灯片和视频放网上，那去会场的意义何在？我觉得有这么几点：</p><ol><li>沉浸式体验：参考电影，你在家看电影和在电影院看电影效果肯定不一样。而且这次 CSSConfCN 和 VueConfCN 刚好都是在 IMAX 影院办的，这个我觉得不需要多解释了。</li><li>细节和时效性：你在会场可以看到分享中的每一个细节，比如分享者对每一张幻灯片中晦涩内容的解释，甚至在讲的过程中的一个表情，一个动作，一个互动，都在传递着很丰富的信息。这不是你会后看幻灯片或看视频能够切身体会的。很多关键的东西都在细节里。而且你如果有任何问题现场就可以趁热打铁问出来并得到回答或讨论。另外时效性其实对于真的技术狂热者来说是很重要的，比如有些人，包括我在内，是习惯于每次苹果发布会都会准时看直播的，而不会接受第二天早上起来再看重播或听比人二次解读，某种角度这是你对技术的态度和信仰问题。这个观点可能有些主观，但我还是愿意把这个观点抛出来，大家可以对号入座看看自己有没有这方面的感觉。再稍微延伸一点，就是我们周围似乎不太有那种欣赏“live”的文化，因为“live”有一种完全真实的魅力。这个世界有太多不真实，我们应该珍惜身边这些为数不多的真实的东西。</li><li>社交的好机会：这一方面裕波在上个月月底的 VueConfCN 也谈过。一个技术会议除了会议内容之外同时也是同好聚会的好时机，这是一个很明显的附加价值。你肯定认同，在网上跟人讨论问题和面对面交流的效率和效果是完全不同的，而且很多人线上线下是完全两种性格。所以不管你是对人有兴趣还是对事有兴趣，技术会议都是个好机会。不过我想补充的一点是，相比起会议内容来说，社交机会只是一个附加价值，不然就不能算是技术会议了。我之前参加过的一些会议似乎不是这么理解的，搞得花里胡哨的，内容沦为辅助品。这种会议的社交质量通常也不高。</li></ol><h3 id="关于门票和票价"><a href="#关于门票和票价" class="headerlink" title="关于门票和票价"></a>关于门票和票价</h3><p>这个问题我不用复述了，大家应该知道这是个什么问题，以我自己的角度和观察来讲：</p><ol><li>我们周围的现状就是大家创造知识和内容很难赚钱，同理你利用这些知识再创造也是很廉价的，用来写书做教程也不赚钱，用来找工作薪水也不高，所以大家都觉得自己没钱，然后没钱就越不愿意为知识和内容付费。所以为知识和内容明码标价和付费是一个好的良性循环。整体上带来的正面的东西大过负面的。技术会议本质上是一种知识传授，至少是交流我觉得。</li><li>你可能客观上明白这个道理，但主观上心态上接受不了，或者仍然觉得这些知识不值票价这个钱。我提供两个参考建议：第一，你去看看我这篇文章第一段贴出来的三个会议，打听一下票价都多少钱——我们周围早期的技术会议都不收钱，多半会方是有“投资”或“奉献”心态的，但请你了解每个技术会议背后真正的一般社会必要劳动时间，也就是价值；第二，只要是你有选择的事情，都没有必要站在某种高度去吐槽或谴责，就我而言，有价值的会，我会参加，而且参加过后有收获也愿意分享出来，这足矣。别的会我看都不看一眼，那不关我的事。那些会可能就不是为我准备的，能一直办下来说明有他们的目的和受众，他们开心就好，跟我没关系。希望给你个参考，懂得尊重，更懂得选择。</li><li>是给会务方的小建议，你永远无法满足所有人，所以网上有人吐槽这本身不可怕，我觉得重点是<ol><li>会务方的目标用户满不满意，这比什么都重要</li><li>你有没有宣传到你的目标用户</li><li>你有没有尽量避免频繁宣传给不是你的目标用户<s>还特别喜欢对别人指指点点</s>的那帮人 (如果他不是你的目标用户，又被过度宣传，这就构成了干扰，他当然有权利发表各种主观抱怨)</li><li>吐槽有没有道理，有没有值得反思的地方，就算再难听。吐槽有理+有礼，可以考虑回馈一下，难听的不必</li></ol></li></ol><h3 id="会议质量"><a href="#会议质量" class="headerlink" title="会议质量"></a>会议质量</h3><p>质量是会议的最核心，相信这一点大家都认同，我觉得最重要的三个部分包括：内容质量、会务质量、社交质量。</p><h4 id="内容质量"><a href="#内容质量" class="headerlink" title="内容质量"></a>内容质量</h4><p>技术会议的内容我总结绝大多数可归为三大类：</p><ol><li>知识分享：客观存在的知识点和方法论</li><li>观点分享：分享者个人对某些事情的主观看法</li><li>案例分享：分享对某些知识的实践经验</li></ol><p>三类分享都有各自的价值和侧重点。有人说其实今天的分享还有第四种就是广告，我一半认同一半不认同，认同的部分是确实有广告，而且有很烦人甚至有很恶心的广告，不认同的部分是它们都是上述三种形式的广告。所以广告本身不是重点，甚至理论上所有的分享都是广义上的“广告”，重点是烦人、恶心、手段拙劣、违和的广告。</p><p>所以这个问题的重点来了，如何鉴定一个东西是不是这种狭义的广告？如果这个问题有答案，那么内容质量是不是就可以有进一步的保证？</p><p>我觉得这个更多是会议组织者要思考的问题，但答案来自参会者。我有一个建议的判断方式：你判断听众会从这个话题得到什么真正的价值。总体上征集来的话题都可以这样判断一下，而主办方主动联系到的讲师，我建议在沟通好大框架的前提下，尽可能的给予讲师们信任和尊重——至少我个人比较反感主办方安排的什么试讲、审稿之类的环节，这种会除非有什么我不得不参加的理由，否则我一定不参加。</p><p>除此之外，有些狭义的广告是会议组织者为了收支平衡有意加进去的，甚至有些会议是明示这个分享是来自赞助商的。说到这里你再想想之前门票和票价那个问题，如果你觉得技术会议没价值，是不是也有你自己的问题？是不是你自己总是图便宜去参加了那些廉价的会才有了这种感受？</p><h4 id="会务质量"><a href="#会务质量" class="headerlink" title="会务质量"></a>会务质量</h4><p>会务质量我觉得说白了就是做会场体验吧，可能也包括讲师体验。现场的屏幕、话筒、灯光、座位这些硬件就不多说了，很多体验其实是体现在软件上，也就是一些人性化的细节。再详细的我也说不上来了，但是参加的会议越多，尤其是今年参加的这几个境外的会议，让我越发觉得，这是个很开放的话题，没有最好，只有更好。</p><p>我只有一个细节想展开谈一下，就是语言和翻译的问题。众所周知，很多优秀的技术都是来自于国外的，更准确的说是来自全球的。如果一个以中文为主的技术会议有“老外”的存在，那么很多大家习以为常的事情都会变成问题。有些问题很明显，比如参会者可能会听不懂“老外”在讲什么；有些问题不那么明显，比如“老外”听不懂其他讲师在讲什么；还有一些问题可能藏得更深，比如“老外”们需要长途跋涉来开会并且很有可能全天听不懂都别人在讲什么，白白浪费一天时间，但是还要愿意精心准备一个技术分享等等。</p><p>我想稍微分享一些参加几个境外会议发现的小细节：</p><ol><li>HK 的 WebConf Asia 是全英文的，这意味着一种化学反应的发生，就是作为讲师本身来参加这个会也是非常有收获的，他们可以现场听其他几位讲师的分享，相互探讨技术问题，所以更有参与感，更有意愿和动力参加这样的会议，并准备更优质饱满的内容出来。VueFes JP 则是一半英文讲师一半本地日文讲师，分两个会场，英文讲师们可以全程听到英文的分享并且有机会参与互动。</li><li>VueFes JP 会非常细心的提前一段时间和讲师确认 slides 的内容，并且做逐片的日文翻译，尽可能的让更多的英语有障碍的同学能够理解和跟上分享的内容。除此之外，小右在早上主讲 keynote 的时候，屏幕上会有实时的日文弹幕对当前的内容进行解释——即便 slides 已经全部是日文翻译过的。我猜测会议组织者可能会根据现场参会者的反应或主讲者的语速来补充一些信息，但同时又不会干扰主讲者的节奏，所以采取这样的措施。而且弹幕不是我们常见的那种很张扬很屌丝的弹幕，只是很低调的在屏幕下方缓缓划过。觉得这样的做法很人性化同时又不失体面。</li><li>在 VueFes JP 的英文讲师的问答环节，所有的问题都是提问者直接，或委托主持人，用英文和讲师提问交流，英文讲师会第一时间得到完整的沟通，然后提问者或被委托的主持人谢过讲师之后，再转身用日语复述他的问题以及他们之间完整的对话，以保证在场的所有人都不错过任何信息。这种注重礼仪的细节让我印象深刻。咱们周围的技术会议都怎么做的我就不做对比了，还是那句话，没有最好，只有更好。稍微对礼数有一些敏感的人应该都能明白我在说什么。</li><li>VueFes JP 的主办方为英文讲师们安排的热情款待我全程看在眼里。除了为讲师们提前沟通安排好全部的行程，包括会前会后的出行，还精心安排了一些感受日本文化的活动，比如品尝日式烧烤、泡温泉、唱卡拉OK (没错别忘了这可是日本的伟大发明，老外对这项活动超新鲜超喜欢) 等等，并且特意安排英文比较好的同学始终在陪同着。更让我没想到的是安排了一位在日本工作的华人在会场帮助我，可以说是非常用心了。</li></ol><h4 id="社交质量"><a href="#社交质量" class="headerlink" title="社交质量"></a>社交质量</h4><p>我个人的经验是：对于一个周六全天的会来说，会议可能只是一白天的，但是社交活动可以是从前一天晚上开始到会议第二天白天才结束的。</p><ul><li>首先，大家为了参加白天的会议，不管是不是本地人，绝大多数情况前一天晚上都应该到了。所以可以以各种方式联系一些同仁吃顿夜宵聊一聊，同时也借此机会认识一些“朋友的朋友”。有些会议会组织官方的 pre-party，比如 WebConf Asia 就组织了一个 pre-party 大家都可以自由参加，费用 AA 结算。通常这种 pre-party 都会让大家挨个儿介绍自己相互认识，然后再开吃开聊。这样在第二天的会议之前，你已经和很多人混熟了，开会的时候就不会显得拘束，而且大概率上，你第二天开会会跟前一天聊得比较好的人坐在一起，一边听讲，一边和周围的朋友探讨相关问题。</li><li>会议过程中，QA和茶歇的机会都是非常宝贵的交流机会，甚至包括用餐的机会。在 ModernWeb TW 和 VueFes JP 的时候，讲师们是有比较独立的用餐选项的，这个时候可能更多的是讲师们彼此交流，在 WebConf Asia 的时候，大家 pre-party、午餐、after-party 都是和讲师们在一块儿的，所以你有任何问题都可以和讲师们做充分的交流。而 QA 这个环节同样是很宝贵，因为通常这是讲师们刚刚分享完自己的想法，大家都处在趁热打铁的状态。我在 ModernWeb TW 的时候经历了一种不太一样的 QA 体验，就是在分享结束之后，讲师会在公共休息区有一张属于自己的桌子，大家对讲师有任何问题都可以来到这张桌子排队提问。这样的好处是：1 所有的交流都是一对一的，所以交流的质量非常高，并且你如果没有问题要问也可以站在边上旁听，同样可以听到很多内容；2 因为讲师已经离开了讲台，所以你不用担心问题问太多影响第二个分享，基本上每一位讲师都是等大家全都问完为止，然后再回去听别的分享，所以你只要有问题是一定问得到的。</li><li>在茶歇的时候，建议大家不要害羞，主动认识更多的人，你可以围观别人的讨论，并且在适当的时机参与进去，提出自己的观点或问题，也可以主动向讲师或一些你已经认识的人抛出一些问题，如果话题足够吸引人的话，一定也会有更多的人参与进来，这样你就有机会认识更多的人，也了解每个人的技术看法和性格。同理 after-party 很多会议也是会安排的，同样是很好的机会，一般也有挨个儿自我介绍的环节。</li><li>参加完一天的会还意犹未尽吗？你还可以考虑第二天参加一些大家自发组织的当地一日游，这是一种更加轻松自在的活动，如果你真的发现在会上遇到了一些特别聊得来的人，可以考虑相互约一下。一边旅游一边交朋友一边聊技术聊人生。</li></ul><p>大概就是这样。</p><p>最后我想鼓励大家多学习英文，多出去走走。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如题，今年陆续参加了一些技术会议，有些新的感触，尤其是今年第一次尝试多参加了一些境外的会议，有在 &lt;a href=&quot;https://www.webconf.asia&quot;&gt;HK&lt;/a&gt; 的，有在 &lt;a href=&quot;https://modernweb.tw/2018/&quot;&gt;TW&lt;/a&gt; 的，有在 &lt;a href=&quot;https://vuefes.jp&quot;&gt;JP&lt;/a&gt; 的，感受很不一样，当然也参加了年初的厦门 CSSConfCN 和刚结束的 VueConfCN。另外网上越来越多人在讨论或是质疑参加技术会议到底有什么意义、好的技术会议应该是什么样子的，我也以写这篇博客的方式参与一下。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>VueConf Hangzhou 见闻</title>
    <link href="https://jiongks.name//blog/vueconf-hangzhou/"/>
    <id>https://jiongks.name//blog/vueconf-hangzhou/</id>
    <published>2018-12-05T04:37:32.000Z</published>
    <updated>2021-02-06T14:42:25.201Z</updated>
    
    <content type="html"><![CDATA[<p><s>先说</s>分享一些自己参加 <a href="https://vueconf.cn/">VueConf Hangzhou</a> 的流水账见闻。</p><p><img src="/images/vueconf-hangzhou.jpg" alt=""></p><a id="more"></a><h3 id="Vue-3-0"><a href="#Vue-3-0" class="headerlink" title="Vue 3.0"></a>Vue 3.0</h3><p>这是绕不开的话题。也是来自小右的第一个大会分享。</p><p>坦白说这部分内容我之前是有所了解的，也参与过内部讨论和之前的一些宣讲。所以听的时候心态相对比较平静。我个人觉得比较值得关注的地方是：</p><ol><li>数据系统升级，支持新的 ES 数据类型，基于 ES Proxy/Reflect 实现，支持 reactive/immutable 两种数据结构</li><li>更友好的 virtual-DOM 底层设计</li><li>基于 ES Class 的组件定义方式</li><li>支持非源码级别的，甚至可以运行时的，定义并替换渲染器：如浏览器、Weex、(将来很可能会有) 小程序等</li><li>支持模块级维护和替换：<code>observer</code>, <code>compiler</code>, <code>runtime-core</code>, <code>runtime-web</code>, <code>runtime-server</code>, …</li></ol><p>当然其它贴心功能，包括模板支持 source map、time slicing、hooks、typescript 支持以及性能和包大小方面的进一步改进等，相信也让很多人为之兴奋。这里不一一列举。</p><p>另外分享一下我看到和理解的 Vue 3.0 相关计划背后的一些东西：</p><ul><li>为更健壮的技术核心服务：Vue 发展到今天，可能大家会有不同的解读，但我体会一个强健的核心是成败的最关键，3.0 在框架核心的健壮性方面做了很多改进，包括全部使用 ts 撰写、分多模块维护等，让更多人可以参与到核心代码工作中来，也让维护成本更低、犯错成本更高。</li><li>为建设更健壮的技术生态服务：包括 virtual-DOM 底层改造和非源码级别耦合的自定义渲染器在内的改进，都可以使上层技术生态更加优质和收敛。这也有助于 Vue 开发者之间的相互交流和协作，顺便提一句 Vue 的官方文档现在除了教程和 API 之外，已经加入了更多的包括 style guide、cookbook 这样的部分，也是在为相同的目标而努力。</li><li>为新技术时代的到来铺路：Vue 一直选择主动拥抱 ES Class、Proxy/Reflect、Set/Map、TypeScript、Web Components 这样的新技术，一方面在对未来作准备，同时也一定程度引导了开发者对新技术有更深刻的了解和更直观的体会。小程序算不算新<em>技术</em>我觉得还是有争议，但反正渲染器也可以自定义了，未来的想象空间还是很大的。</li></ul><p>不出意外的话，接下来 3.0 会经历一个逐步迭代和打磨的过程。在这个过程中，可能还会有一些新的特性或变化产生。但总体上，我预测翻天覆地的变化不太可能出现，新版本的主体思想应该也不会变。我个人理解，近期前端开发的模式，尤其是框架这一层，有逐渐稳定的趋势，大家基本都不约而同的专注在组件系统和数据管理这两个大的部分。技术手段在语言特性本身没有 ES5、ES6 那两波重大革新和突破的前提下，也鲜有质的提升。所以这个时候上层生态的作用和意义会越来越凸显出来。这个时候，严把框架质量关 + 更多为上层生态服务是非常明智的选择。</p><p>当然再次强调这是我个人的观点和判断，接受反驳。</p><h3 id="其它议题的感受"><a href="#其它议题的感受" class="headerlink" title="其它议题的感受"></a>其它议题的感受</h3><h4 id="Vue-声明式交互能力"><a href="#Vue-声明式交互能力" class="headerlink" title="Vue 声明式交互能力"></a>Vue 声明式交互能力</h4><p>这个话题我之前跟分享者 寒老师 也有过私下讨论，当时讨论的内容我甚至认为要比 寒老师 会上分享的还要深入，包括延伸到了 MVVM 设计理念的一些细节，所以 Vue 模板的图灵完备性跟这些相比可能只是冰山一角了。比如我相信今天几乎每个前端工程，不仅限基于 Vue 开发的项目，都有很复杂的数据，也就是 MVVM 里的 Model 或 Flux 里的 Store，需要设计、维护和“定期治理”。我觉得从今天前端工程的角度看，MVVM 描述的有些抽象，和实际的场景和语言特性有距离；而 Flux 实践性更强，但是理论层面没有 MVVM 探讨得那么细致和严谨，所以走到某些特殊的业务逻辑的时候你还是会困惑。在和 寒老师 讨论之后，我有了一些新的思路，打算接下来花精力做一些试验。更具体的内容就要等以后有了什么新的结论再做分享了。</p><h4 id="Vue-CLI-相关"><a href="#Vue-CLI-相关" class="headerlink" title="Vue CLI 相关"></a>Vue CLI 相关</h4><p>CLI 应该算是 Vue 最近一年时间里在工具层面最重要的一个发布了。在维护者 胖茶 分享的每一个设计细节中，我感触比较深的，一个是为 vue-loader 和 webpack config 解压，同时避免社区和生态在这个层面过度碎片化；另外 CLI 在项目的技术升级和配置模板等方面下了很多功夫，这是很多开发者<em>有需求但是不敢乱动或越改越花</em>的两个地方；最后想说 韦元悦 的闪电分享有些仓促，但有两个重点大家可能 get 到了：一个是 Vue CLI 的可扩展性是很高的，另一个是 Vue CLI 的 GUI 界面，因为随着前端工程化的发展，一个可视化的项目管理与配置变得越来越有价值了。</p><p>顺便提一下，除了 CLI，还有一个工具也值得推荐大家关注，就是 VuePress。而且这两个工具目前都是国人在维护。很赞。</p><h4 id="Vue-生态"><a href="#Vue-生态" class="headerlink" title="Vue 生态"></a>Vue 生态</h4><p>下午的 And Design Vue、Electron-Vue、Hippy-Vue 三个分享都是 Vue 社区和生态的部分，分别对应了组件库、桌面应用、移动应用三个大的板块。虽然大家未必都用得到，但我理解这是 Vue 社区和生态广度的一个展现。</p><p>另外两个跟 Vue 的招牌特性实践有关：SFC 和 SSR。SFC 实践的分享来自淘宝，这算是淘宝对 Vue 的一个认可吧我觉得，前东家的东西我就不做更多解读和演绎了；SSR 实践的分享我和分享者 天翔 之前也聊过一些，其实这个分享没有很多对 SSR 本身特性的介绍，更多的是探讨在 SSR 业务场景下的数据管理问题，我意识到这个话题其实和 寒老师 的话题存在着某种诡异的联系，因为本质上都是 UI 和数据打交道。同样的今天先不展开了。</p><p>最后 CRDT 这个分享的内容坦白说是在我意料之外的，第一是我没想到 ai 哥直接从 PostCSS 跳到了看上去完全不搭嘎的新领域，来以分布式的视角探讨数据交互；第二是我没想到能够学到“从 CS 学科过去几十年的积累中寻求新问题灵感”的这种方法论。它带给我的启发远远大过了 CRDT 本身。</p><h4 id="Bonus：Hax-关于-ES-新规范的闪电分享"><a href="#Bonus：Hax-关于-ES-新规范的闪电分享" class="headerlink" title="Bonus：Hax 关于 ES 新规范的闪电分享"></a>Bonus：Hax 关于 ES 新规范的闪电分享</h4><p>因为 Vue 3.0 会提供 ES class 形式的 API，所以与此相关的 ES 规范也会逐渐成为每一个 Vue 开发者关注的话题。关于 Hax 在会上提到的 ES 新规范，我个人比较明确的态度就是我不喜欢用 <code>#</code> 来表示私有成员，比如 <code>this#foo</code>。不喜欢的原因实在太多了我都不知道该从哪条开始说了，而且 Hax 基本都提到过了，我就不复述了，另外你可能会说你不喜欢就给个喜欢的啊不然还废什么话，坦白说我现在也给不出更好的方案，但我觉得如果一个新规范讨论不到够好的话，我宁愿没有这个规范，这不是一个一定要立刻有结论的事情。另外现在可能更大的问题是它眼瞅着要被通过了，我们该怎么办？这可能也是 Hax 想表达的一个很重要的点。如果你有关注规范和语言特性的习惯的话，建议多了解一下这方面的内容。</p><p>总体上，我自己觉得这次 VueConf Hangzhou 非常棒！</p><p>当然也因为自己有幸参与开场的乐队表演，而且表演了自己参与创作的歌，觉得很荣幸。</p><p><em>本来这篇文章的标题打算定为《VueConf Hangzhou 见闻，以及一些对技术会议的看法》，因为这次 VueConf Hangzhou 不出意外是我今年参加的最后一个技术会议了，不过写到这里发现内容已经不少了，另外也是个人时间的关系，所以打算先写到这里了。对技术会议的看法我会将来再找机会写。</em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;s&gt;先说&lt;/s&gt;分享一些自己参加 &lt;a href=&quot;https://vueconf.cn/&quot;&gt;VueConf Hangzhou&lt;/a&gt; 的流水账见闻。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/vueconf-hangzhou.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="vue" scheme="https://jiongks.name/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>第四届 CSSConf CN 见闻</title>
    <link href="https://jiongks.name//blog/cssconf-cn-4/"/>
    <id>https://jiongks.name//blog/cssconf-cn-4/</id>
    <published>2018-04-03T10:49:26.000Z</published>
    <updated>2018-04-03T11:03:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>上周末作为一名分享者参加了 <a href="https://css.w3ctech.com/">CSSConf CN</a>，在厦门。</p><p>其实除了自己的分享内容，这次我是带着很明确的目的参会的，因为有两个主题我特别关注，就是：</p><ul><li>第一个：响应式的组件</li><li>第三个：从 API 的角度看组件的 CSS</li></ul><p>(两个分享的标题都被我稍微“演绎”了一下)</p><p>这两件事都是自己工作上正在特别关注的事情，一方面，我们很少从 API 的角度去理解一个组件的 CSS 该如何组织和管理，所以这个标题就特别吸引我，另一方面响应式组件的分享者是来自新加坡的前端工程师 Zell (我个人一直觉得国内的响应式都是在瞎搞，看了很多周围团队都没有认真做这件事，甚至不相信响应式的价值，从设计师到工程师)，因此非常珍惜这个机会能近距离学习一些国外的同行们是怎么看待和实践响应式的。</p><p>所以尽管我们团队的差旅经费已经用完了，还是决定自费来厦门近距离交流一下。</p><p>现在证明这次真的不虚此行。</p><p>当然参加这种线下活动，“面基”的目的是一定有的……恩，这个不值一提。</p><a id="more"></a><h3 id="响应式组件"><a href="#响应式组件" class="headerlink" title="响应式组件"></a>响应式组件</h3><p>在谈这次分享内容给我的收获之前，我想说，实际上我不只是从几十分钟的分享中学习了响应式组件的东西。我这次去厦门的行程特地提前了两天，周四就到厦门了，就是希望能多一些分享的准备和现场交流。正好 Zell 也到的比较早，于是乎我在周末的会议之前就跟 Zell 聊了很多。真的是很难得的机会。</p><p>回到分享的内容，我听过 Zell 的分享之后简单整理了一些要点：</p><ol><li>Proportional scaling：让所有的组件成比例<ul><li>注意字号：<code>font-size</code> 尽量使用 <code>em</code> 单位，而不是如 <code>px</code> 的绝对单位</li><li>注意视口/窗口大小 (viewport)：尽量使用 <code>vw</code>、<code>vh</code>、<code>vmin</code>、<code>vmax</code> 单位，必要的时候可以配合 <code>calc()</code></li></ul></li><li>Responsive scaling：处理好响应式的断点<ul><li>善用 media query</li><li>尽可能使用 <code>min-width</code>，以小屏幕为基础</li><li>必要的时候使用 <code>min-width</code> 和 <code>max-width</code> 的交集，避免样式间不必要的相互干扰</li></ul></li><li>Modular scaling：像乐高一样拼合模块时的注意事项<ul><li>不要在子元素上直接设置外边距</li><li>取而代之的是在父元素上整体设置每个子元素的边距<ul><li>巧用 <code>+</code> 选择器处理最后一个元素多余的边距</li></ul></li><li>在需要对其的地方使用 <code>rem</code> 作为边距的单位以避免被组件的字号影响布局</li></ul></li><li>Morphable blocks：尽可能透过不同的表象提炼相同结构的组件，以达到尽可能的复用和组件数最小化<ul><li>找出相同点和不同点</li><li>得出最佳的 HTML 结构</li><li>通过设置不同的样式展示出不同的效果</li><li>让 modifier (BEM 中的 M) 的数量尽可能的少</li></ul></li><li>额外的小贴士：命名规范和约定、避免在选择器上使用 ID 从而使得选择器的权重失控</li></ol><p>实际上每一条都不是很难，也不是没有见到过，但是总结的非常有系统性，给了大家一些很好开始的着手点。</p><p>另外 Zell 在聊天过程中也提到了很多我非常认同的观点和细节，想分享给大家：</p><ul><li>前端工程师是真正用户体验的“最后一道门”，身为前端工程师一定要有意识捍卫用户体验 (这句话后来跟 裕波 聊天的时候他说了一模一样的话，可见大家都十分认同)。</li><li>前端工程师一定要跟设计师“坐在一起”工作，一定要强沟通，才能把工作做好。</li><li>跟 Zell 聊到响应式在自己的工作中遇到很多困难的时候，Zell 出乎意料的大方对我说“你找我就对了”，即大方又自信。看得出来响应式在 Zell 看来已经是吃饭喝水一样了，我们自己包括周围的人却连一步都还没走出来，真是觉得惭愧。</li></ul><h3 id="从-API-的角度看组件的-CSS"><a href="#从-API-的角度看组件的-CSS" class="headerlink" title="从 API 的角度看组件的 CSS"></a>从 API 的角度看组件的 CSS</h3><p>我记录了一些要点和自己的理解：</p><ul><li>首先，通过 CSS 的发展史来看，我们一直试图通过一种特定的语法 (CSS) 来描述网页的样式，但在 web page -&gt; web app 的划时代趋势下，我们组织代码的方式也发生了变化，尤其是 CSS 的部分容易被人们忽视。</li><li>分享者 E0 把今天的 CSS 设计问题，从 API 的角度划分成了三个层次：<ol><li>对于组件的维护者来说：要把一部分 CSS 样式封装起来，供自己维护，同时也要避免被组件的使用者误修改或滥修改，通常这些样式会被内联或编译为无语义不可编辑的 CSS class</li><li>对于组件的使用者来说：要把一部分 CSS 用法暴露出来，供开发者灵活配置或修改，很多组件库会在文档中列出可以配置和修改的 CSS class，但除此之外，还有一些库做了很巧妙的不一样的封装，比如通过扩展的伪类或伪元素。这种方式我之前没有留意到过，有点开眼界</li><li>对于浏览器插件作者：这个角度也是我之前没有认真思考过的，就是说还有这样一群开发者，希望通过浏览器插件处理一些不同用户的特定需求。如果我们的组件希望对这些人友好，那么就多了一层考量。这时我们就想到了一些更加通用或规范化的，和具体工具、库、编译方式无关的设计，比如 CSS 自定义属性、无权重的选择器等</li></ol></li></ul><p>听过之后非常受启发。</p><p>这两份 slides 我也第一时间分享给了我们团队组件库的同学们了解学习了：）</p><h3 id="关于自己分享的-CSS-Houdini"><a href="#关于自己分享的-CSS-Houdini" class="headerlink" title="关于自己分享的 CSS Houdini"></a>关于自己分享的 CSS Houdini</h3><p>这些内容可能真的是有一点“超前”了，因为很多浏览器都还没实现，而且规范本身也没有稳定下来。但是我迫不及待的想分享出来，是因为我也听到了一些说法，说“CSS 很久没有什么新闻了”。那 CSS Houdini 绝对是一个可以让 CSS 更上一层楼的“重量级”的东西。希望可以通过分享 CSS Houdini 让大家对 CSS 更有信心和期待。</p><p>同时很多技术的“风向”都是由最底层的东西决定的，我们从规范层面对 CSS 有更多的了解，一定会对我们的实际工作有很多指导和借鉴的价值。如果你同时还是一个有开源精神的人，那么你可以从今天开始就构思一些基于 CSS Houdini 的工具和库了对吧，用这些工具和库加速 CSS Houdini 的落地，同时也尽快把一些之前没有 CSS Houdini 的时候大家用起来很别扭很勉强的东西汰换掉，更在这个过程中体会 web 带给我们的乐趣：）</p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>另外几个分享也各有特色，总体上，我觉得这次 CSSConf CN 同时包含了 CSS 的规范、理念、工具、技巧、动画、八卦、吐槽各个方面，应该是尽可能照顾到了大家的兴趣和需求了。还是觉得这样的会议非常的棒。</p><p>我觉得 CSS 和动画、SVG、字体设计、3D 图形学、可访问性、语义化的 web 等话题有着非常紧密的联系，有很多有意义的延伸，并且这些话题也很难有独立的 Conf 了吧我估计。再加上 CSSConf 的主办者们，尤其是 裕波，是非常懂前端开发者们的，他们经营 CSSConf 的理念和方式我一直非常认同和欣赏，所以也许未来有一天，CSSConf 会比 JSConf 更受人关注。</p><p>以上</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上周末作为一名分享者参加了 &lt;a href=&quot;https://css.w3ctech.com/&quot;&gt;CSSConf CN&lt;/a&gt;，在厦门。&lt;/p&gt;
&lt;p&gt;其实除了自己的分享内容，这次我是带着很明确的目的参会的，因为有两个主题我特别关注，就是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一个：响应式的组件&lt;/li&gt;
&lt;li&gt;第三个：从 API 的角度看组件的 CSS&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(两个分享的标题都被我稍微“演绎”了一下)&lt;/p&gt;
&lt;p&gt;这两件事都是自己工作上正在特别关注的事情，一方面，我们很少从 API 的角度去理解一个组件的 CSS 该如何组织和管理，所以这个标题就特别吸引我，另一方面响应式组件的分享者是来自新加坡的前端工程师 Zell (我个人一直觉得国内的响应式都是在瞎搞，看了很多周围团队都没有认真做这件事，甚至不相信响应式的价值，从设计师到工程师)，因此非常珍惜这个机会能近距离学习一些国外的同行们是怎么看待和实践响应式的。&lt;/p&gt;
&lt;p&gt;所以尽管我们团队的差旅经费已经用完了，还是决定自费来厦门近距离交流一下。&lt;/p&gt;
&lt;p&gt;现在证明这次真的不虚此行。&lt;/p&gt;
&lt;p&gt;当然参加这种线下活动，“面基”的目的是一定有的……恩，这个不值一提。&lt;/p&gt;
    
    </summary>
    
    
      <category term="css" scheme="https://jiongks.name/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>[译]Web 表单的未来</title>
    <link href="https://jiongks.name//blog/the-future-of-web-forms/"/>
    <id>https://jiongks.name//blog/the-future-of-web-forms/</id>
    <published>2017-08-04T11:00:16.000Z</published>
    <updated>2017-08-04T11:05:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><mark>译自：<a href="https://blog.prototypr.io/the-future-of-web-forms-4578485e1461">https://blog.prototypr.io/the-future-of-web-forms-4578485e1461</a> Matt West 的 The Future of Web Forms</mark></p><p>license: <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a></p><hr><p>如何通过会话式的界面让数据收集更加人性化。</p><p>Web 表单是从纸质媒介进化而来的。即设计一组标签和线框来限制输入，同时让数据处理变得跟容易。</p><p>毕竟，表单的目的是收集数据，以便执行操作。为了执行该操作，我们需要把收集的数据统一汇总。我们在界面上设计了一些约束以便达到统一汇总的目的。表单旨在符合流程上的需求，而非用户本身。</p><p>表单经常给人的感觉是冷冰冰的，没有人情味。因此，我们得到的回应往往也是冷酷和不人性的。我们不深入细节，如果一个朋友问你相同的问题，你可能会多一些回复，但这是一台电脑。他想要的只是数据，别的不在乎。就好像你在跟人说话但是人家并没有在听。为什么没人听的话说出来会让人觉得烦呢？</p><p><img src="/uploads/2017/08/3710637212.jpg" alt=""><br>Image by <a href="https://www.flickr.com/photos/teegardin/5512347305/in/photolist-9p7dNM-nfdbBe-cDphCL-9xSJ1E-4ygMXx-6jXLSo-9oAgas-nytcFV-aXPWKv-2rxaS-6jXZNW-oTkWEk-iYYsDH-pMeotq-5SLAGV-6jERwK-6jBcih-iq2oUj-9c36uA-6wAbW4-7vWrZv-dRsLkh-99N1pk-g1vCAm-g4P8w-eSo6V4-biaFTP-6jk9td-J9DyZ-cQay4s-6jXYcS-9PSLHY-iYKUVr-h5Eh26-6jBXaA-7vTL6V-pMfC4t-5u8Nod-7b3sfu-fdPdkW-7vVobi-5Tscj8-7vUV6p-bDw2PE-6jxKBi-5Tww8J-89GCkF-6jxKTi-6jBWUG-eiwixk">Ken Teegardin</a>.</p><p>和许多数字化的东西一样，表单已经被之前的形态严重影响。我们之所以往线框里填东西是因为我们以前在纸上就是这么画的。</p><a id="more"></a><p>我们在纸上主要的输入法是钢笔或铅笔。现在已经不一样了，我们被上百年的约束限制了自己。</p><p>技术已经从这些约束中解放了我们。我们已经拥有了创建更人性化的人机交互的工具。</p><p><img src="/uploads/2017/08/4181232011.jpg" alt=""><br>Spike Jonze’s film “Her” provides an interesting prediction for how we might interact with computers in the future.</p><p>我们已经很接近在语音识别、自然语言处理和人工智能等方面与人类进行有意义的对话了。甚至我们的工具已经在构建足够优秀的体验了。</p><p>所以我们回到表单。我们该如何使用这些工具使得表单更人性化呢？</p><p>我们需要摆脱之前对于表单界面的预设。聚焦在通过技术构建一个更佳自然的体验，而不是去除操作层面的约束。</p><p><img src="/uploads/2017/08/2141635702.png" alt=""><br>A conversation with Facebooks chat bot “Poncho”.</p><p>在过去几年中，我们已经看到了一些新产品致力于通过科技让我们的交互更自然。Siri、Alexa、chat bots 都让我们朝着正确的方向发展，但是我们还没有看到这些创新以某种方式融入到浏览器界面中。</p><p>我们有非常多的潜力在更加会话式的 web 界面上，当我们需要收集数据时，我们仍然从一堆输入框和下拉框中构建表单。</p><p>有些人在推动这件事。保险服务 <a href="https://withjack.co.uk/quote/">Jack</a> 最近发布了一个令人印象深刻的页面来收集保险报价所需的细节。</p><p><img src="/uploads/2017/08/1469363781.png" alt=""><br>The “Get a Quote” page from <a href="https://withjack.co.uk/">withjack.co.uk</a></p><p>虽然回复依然是被约束的，但是这个收集数据的设计流程已经创造出了更加愉悦和友善的体验。</p><p>向用户展示一个标准的 web 表单因此而变得更加容易，但是这样的用户交互更像是一个会话的过程，Jack 已经创造出了更加自然的感受。</p><p><img src="/uploads/2017/08/993446137.png" alt=""><br>Adrian Zumbrunnen’s conversations website <a href="http://azumbrunnen.me/">azumbrunnen.me</a></p><p>Adrian Zumbrunnen 在发布他的会话式的个人网站之后引起了互联网的关注。Adrian 设计了一个界面，通过一些回复选项来引导用户浏览他的 UI/UX 作品。Adrian 的网站巧妙的考虑到了用户如何到达他的网站并以此为信号来理解用户所处的情景。</p><p>我们的方向是对的，但感觉还是少了什么。从技术角度看，构建一个真实的会话式界面需要理解用户的意图和语境，而不仅仅是一些回复选项和位置摆放很聪明的文本框。我们需要基于已经做好的 chat bot 且开发出能够让人们用自然语言与其交流的界面。</p><p>界面甚至在开始之前就应该知道我们是谁。底层技术已经有现成的了，那就是浏览器的自动填表。你所有的细节都存在同一个地方，对于一个网站来说，一个简单的请求就可以访问。</p><p>该界面应该能够适配当前所处的情境。会话是你是从网站的帮助支持页面开始的还是从营销站点的首页开始的？这些信号可以帮助我们理解用户的语境并为其定制适当的系统回复。这些事情 Adrian 的网站并没有做。</p><p>让我们体验一下如何把用户注册流程变得更加会话式。</p><p><img src="/uploads/2017/08/68310827.png" alt=""><br>What would the sign up flow look like if we moved beyond forms?</p><p>我们今天拥有做这件事相应的数据，但是把所有的东西一起提供出来以创造这样一个自然的体验是真正难的地方。</p><p>再考虑牵连到可访问性、隐私、多语言支持、赋予情绪和同理心的设计。如果我们打算通过技术引入一个全新的更有意义的交互设计，这些都是我们今天要去面临和克服的挑战。</p><p>没想到我们已经走到这么远了，但是这里仍然有很多事情要做。未来就在不远处的转角，但我们要敢于去做才行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;mark&gt;译自：&lt;a href=&quot;https://blog.prototypr.io/the-future-of-web-forms-4578485e1461&quot;&gt;https://blog.prototypr.io/the-future-of-web-forms-4578485e1461&lt;/a&gt; Matt West 的 The Future of Web Forms&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;license: &lt;a href=&quot;https://creativecommons.org/licenses/by-sa/4.0/&quot;&gt;CC BY-SA 4.0&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;如何通过会话式的界面让数据收集更加人性化。&lt;/p&gt;
&lt;p&gt;Web 表单是从纸质媒介进化而来的。即设计一组标签和线框来限制输入，同时让数据处理变得跟容易。&lt;/p&gt;
&lt;p&gt;毕竟，表单的目的是收集数据，以便执行操作。为了执行该操作，我们需要把收集的数据统一汇总。我们在界面上设计了一些约束以便达到统一汇总的目的。表单旨在符合流程上的需求，而非用户本身。&lt;/p&gt;
&lt;p&gt;表单经常给人的感觉是冷冰冰的，没有人情味。因此，我们得到的回应往往也是冷酷和不人性的。我们不深入细节，如果一个朋友问你相同的问题，你可能会多一些回复，但这是一台电脑。他想要的只是数据，别的不在乎。就好像你在跟人说话但是人家并没有在听。为什么没人听的话说出来会让人觉得烦呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/uploads/2017/08/3710637212.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;Image by &lt;a href=&quot;https://www.flickr.com/photos/teegardin/5512347305/in/photolist-9p7dNM-nfdbBe-cDphCL-9xSJ1E-4ygMXx-6jXLSo-9oAgas-nytcFV-aXPWKv-2rxaS-6jXZNW-oTkWEk-iYYsDH-pMeotq-5SLAGV-6jERwK-6jBcih-iq2oUj-9c36uA-6wAbW4-7vWrZv-dRsLkh-99N1pk-g1vCAm-g4P8w-eSo6V4-biaFTP-6jk9td-J9DyZ-cQay4s-6jXYcS-9PSLHY-iYKUVr-h5Eh26-6jBXaA-7vTL6V-pMfC4t-5u8Nod-7b3sfu-fdPdkW-7vVobi-5Tscj8-7vUV6p-bDw2PE-6jxKBi-5Tww8J-89GCkF-6jxKTi-6jBWUG-eiwixk&quot;&gt;Ken Teegardin&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;和许多数字化的东西一样，表单已经被之前的形态严重影响。我们之所以往线框里填东西是因为我们以前在纸上就是这么画的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="表单" scheme="https://jiongks.name/tags/%E8%A1%A8%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>[译]苹果正在做一些他们的程序员明摆着不想要的东西</title>
    <link href="https://jiongks.name//blog/apple-is-about-to-do-something-their-programmers-definitely-dont-want/"/>
    <id>https://jiongks.name//blog/apple-is-about-to-do-something-their-programmers-definitely-dont-want/</id>
    <published>2017-08-01T02:49:46.000Z</published>
    <updated>2017-08-01T02:56:39.000Z</updated>
    
    <content type="html"><![CDATA[<p><mark>译自: <a href="https://medium.com/make-better-software/apple-is-about-to-do-something-their-programmers-definitely-dont-want-fc19f5f4487">https://medium.com/make-better-software/apple-is-about-to-do-something-their-programmers-definitely-dont-want-fc19f5f4487</a></mark></p><p>Jul 29, 2017</p><p>作者 <a href="http://anildash.com/">Anil Dash</a> 是 Fog Creek Software 的 CEO，致力于让科技变得更人性和道德一些，同时他也是 Medium 的顾问。</p><hr><blockquote><p>苹果在 Apple Park 这个漂亮的新办公楼上花了 50 亿美金，却犯了一个完全可以避免的极其昂贵的错误：让他们的程序员工作在一个开放式的格局中。这真让人惊讶。</p></blockquote><p><img src="/uploads/2017/08/2254787802.jpg" alt=""></p><p>我在 Fog Creek Software 工作，我们的联合创始人兼前 CEO <a href="https://medium.com/u/869c7e626b83">Joel Spolsky</a> 在<a href="https://www.joelonsoftware.com/2000/04/19/where-do-these-people-get-their-unoriginal-ideas/">至少 17 年前</a>就已经针对开放式办公室对于程序员产能的糟糕影响撰文了。他在这方面的洞察基于了 Tom DeMarco 和 Tim Lister 的经典书籍<a href="https://en.wikipedia.org/wiki/Peopleware:_Productive_Projects_and_Teams">《Peopleware》</a>——该书已经出版了三十年。所以这其实不是什么全新的观点。当然在这数十年里，也已经有无数的<a href="http://theconversation.com/open-plan-offices-attract-highest-levels-of-worker-dissatisfaction-study-18246">学术研究确认</a>了同一个结论：人们在开放式空间办公是烦躁的、注意力不集中的、常常不开心的。</p><p>这不是说开放式办公环境一无是处——它能够营造很好的协作和联络的氛围。对于市场或销售团队来说，共享空间是非常有意义的。但是对于需要身处某种工作流状态的任务来说呢？这个问题从科学的角度是有定论的。</p><p>那就是把门关上。</p><a id="more"></a><h3 id="保持在工作流中"><a href="#保持在工作流中" class="headerlink" title="保持在工作流中"></a>保持在工作流中</h3><p>现在，如果我们的工作或角色需要特定工作流的时候，那事情就能通过排除一切干扰而获益，编程或许就是这种绝无仅有的最好的例子。而苹果拥有一批这个世界上最顶尖的程序员，所以很显然应该给予他们非常好的环境。</p><p>这就是为什么<a href="https://www.wsj.com/articles/how-jony-ive-masterminded-apples-new-headquarters-1501063201">华尔街日报的这篇醒目的文章</a>里会出现这段关于苹果新总部的尤其刺眼的边注：</p><blockquote><p><strong>数以千计的</strong> Apple Park 的雇员都会出现在 Ive 的办公视线内。很多人都将坐在开放空间，而不是以往的小办公室。<mark>程序员们都会担心他们的工作氛围太过嘈杂和注意力不集中。</mark>……</p></blockquote><p><img src="/uploads/2017/08/941992970.png" alt=""></p><p>通常，公司会以预算为由把程序员安排在开放式办公室。确实让每个程序员都有一个自己的封闭办公室是一笔不小的开销。但是鉴于苹果已经在这个新园区投资了 50 亿美金，且用上了<a href="https://qz.com/905934/even-the-toilets-in-apples-aapl-campus-2-are-inspired-by-the-iphone/">被 iPhone 设计影响了的定制抽水马桶</a>，你很难确信这是因为省钱而做的决定。</p><p>取消私人办公室的另一个可能的原因是，也许公司并不知道它的员工们的喜好。但是这个问题是可测试的——我们不带任何倾向性的暗示，来询问一下大家希望办公室是什么样子的，看看大家的回应如何。</p><blockquote><p>你曾经或现在拥有的办公室里的最好的特点是什么？</p><p>Anil Dash (@anildash)<br>2:47 AM - Jul 19, 2017</p></blockquote><p><a href="https://medium.com/media/1e30d93e0c22e81d448111d4f478fa20?postId=fc19f5f4487">Twitter Link</a></p><p>在数百则回复中，你会发现许多人在谈论他们多么高兴自己有一个，或希望自己有一个可以把门关上的私人办公室。</p><p>毫无疑问如果苹果和他们自己的团队交流过后，能够得到相同的回复。所以唯一剩下的可能就是在这个行业里，没有足够的人真正相信程序员值得拥有一个私人办公室。所以我们会继续大声呼吁这件事情。</p><h3 id="近距离看看"><a href="#近距离看看" class="headerlink" title="近距离看看"></a>近距离看看</h3><p>来参观一下 Fog Creek 在纽约的总部</p><p><img src="/uploads/2017/08/1791376931.jpg" alt=""></p><p><a href="https://www.google.com/maps/@40.706976,-74.0132501,0a,29.2y,273.42h,100.56t/data=!3m4!1e1!3m2!1su6fRkLZ36IAAAAQIt5lP8A!2e0?source=apiv3">Google Map Link</a></p><p>将近二十年前，我记得自己在 Joel 的博客上看到了有关 Fog Creek 新办公室的构造，后来当它完工的时候，我记得看到纽约时报<a href="https://www.nytimes.com/2009/02/08/realestate/commercial/08sqft.html">热切的报道</a>它的创新。在那时，我从未想象过我有一天会在那里工作。我看着那篇文章，脑海里幻想着自己在那里的样子，带有一点怀疑的问这些努力是否值得。</p><p>现在我得承认，当开始想象自己在 Fog Creek 拥有一间新办公室的时候，我一度被诱惑到了，我想知道通过像其它几乎每一家公司一样使用开放式办公室来省一些钱是否真的很好。这样做是很容易的。</p><p>现在 Fog Creek 已经改变了很多——我们公司大约三分之二的工作是远程进行的，尽管几乎所有人都在家中的办公室办公，你猜到了，都是关门的。同时像销售和客服这样的团队从开放式的办公区域中获益。我们可以讨论到所有人的意见一致为止。</p><p>不过即便是共享空间的团队也会因为我们在新办公室里提供了电话亭而兴奋，这会方便他们在一个私人空间里打电话。同时我们的技术人员仍然和以前一样拥有超高的工作效率，没有低效的时段，这可以归功于他们有适合他们工作的正确的环境。</p><p>最重要的是，专注于创造一个非常棒的工作环境，甚至让我们考虑新的想法，来帮助人们同时拥有两个最好的世界，犹如一辆“安静的汽车”置身于一个大型的会议室。这样的地方能让人们坐在一起但同时仍然可以享受安静和平静，灵感来源于大家最喜欢的 <a href="https://www.amtrak.com/onboard-the-train-quiet-car">Amtrak amenity</a>。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>如果一家公司想把产品做得像苹果一样成功，我们永远无法给出建议。尽管我们为 <a href="https://glitch.com/">Glitch</a> 和 <a href="https://fogbugz.com/">FogBugz</a> 而无比的自豪，我们仍然对苹果近几十年来所做的一切深表敬意。但是我们不希望对这个有机会避免的错误袖手旁观而让其继续下去，因为这是一个苹果 (同时也是每一家自己有程序员的公司！) 不费吹灰之力就可以解决的缺点。</p><p>我们很高兴这么多公司知道在他们的雇员身上投资——从医疗保健到最新最棒的计算机硬件的一切东西。但是当他们需要集中精神的时候，也强求每个工作人员都要共享一个开放式的空间时，哪怕是最大最成功的公司也是时候 think different 了吧？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;mark&gt;译自: &lt;a href=&quot;https://medium.com/make-better-software/apple-is-about-to-do-something-their-programmers-definitely-dont-want-fc19f5f4487&quot;&gt;https://medium.com/make-better-software/apple-is-about-to-do-something-their-programmers-definitely-dont-want-fc19f5f4487&lt;/a&gt;&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;Jul 29, 2017&lt;/p&gt;
&lt;p&gt;作者 &lt;a href=&quot;http://anildash.com/&quot;&gt;Anil Dash&lt;/a&gt; 是 Fog Creek Software 的 CEO，致力于让科技变得更人性和道德一些，同时他也是 Medium 的顾问。&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;苹果在 Apple Park 这个漂亮的新办公楼上花了 50 亿美金，却犯了一个完全可以避免的极其昂贵的错误：让他们的程序员工作在一个开放式的格局中。这真让人惊讶。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/uploads/2017/08/2254787802.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我在 Fog Creek Software 工作，我们的联合创始人兼前 CEO &lt;a href=&quot;https://medium.com/u/869c7e626b83&quot;&gt;Joel Spolsky&lt;/a&gt; 在&lt;a href=&quot;https://www.joelonsoftware.com/2000/04/19/where-do-these-people-get-their-unoriginal-ideas/&quot;&gt;至少 17 年前&lt;/a&gt;就已经针对开放式办公室对于程序员产能的糟糕影响撰文了。他在这方面的洞察基于了 Tom DeMarco 和 Tim Lister 的经典书籍&lt;a href=&quot;https://en.wikipedia.org/wiki/Peopleware:_Productive_Projects_and_Teams&quot;&gt;《Peopleware》&lt;/a&gt;——该书已经出版了三十年。所以这其实不是什么全新的观点。当然在这数十年里，也已经有无数的&lt;a href=&quot;http://theconversation.com/open-plan-offices-attract-highest-levels-of-worker-dissatisfaction-study-18246&quot;&gt;学术研究确认&lt;/a&gt;了同一个结论：人们在开放式空间办公是烦躁的、注意力不集中的、常常不开心的。&lt;/p&gt;
&lt;p&gt;这不是说开放式办公环境一无是处——它能够营造很好的协作和联络的氛围。对于市场或销售团队来说，共享空间是非常有意义的。但是对于需要身处某种工作流状态的任务来说呢？这个问题从科学的角度是有定论的。&lt;/p&gt;
&lt;p&gt;那就是把门关上。&lt;/p&gt;
    
    </summary>
    
    
      <category term="苹果" scheme="https://jiongks.name/tags/%E8%8B%B9%E6%9E%9C/"/>
    
      <category term="办公室文化" scheme="https://jiongks.name/tags/%E5%8A%9E%E5%85%AC%E5%AE%A4%E6%96%87%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>[译]为什么我不会无偿加班且你也不应该</title>
    <link href="https://jiongks.name//blog/why-i-dont-unpaid-overtime-and-neither-should-you/"/>
    <id>https://jiongks.name//blog/why-i-dont-unpaid-overtime-and-neither-should-you/</id>
    <published>2017-04-01T08:06:05.000Z</published>
    <updated>2017-08-01T02:57:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><mark>译自：<a href="http://thecodist.com/article/why_i_don_39_t_do_unpaid_overtime_and_neither_should_you">http://thecodist.com/article/why_i_don_39_t_do_unpaid_overtime_and_neither_should_you</a></mark></p><p>原文写于 2012 年，至今已经有一段时间了，前段时间这篇文章又被大家翻出来热烈讨论，看过之后有些感触，所以翻译了一下</p><hr><p>我是一个在美国待了 30 年的程序员，我有过一周工作超过 40 小时的经历，这在行业里面并不常见，但是我<a href="http://dict.cn/rarely">很难</a>因此而得到更多的薪水。</p><p>总之，我现在发现整个做法<a href="http://dict.cn/nauseating">很恶心</a>。</p><p>我并不是针对自营或创业等多干活儿就能得到更多回报的情况。我曾经在 80 年代中期到 90 年代开过两个小的软件公司，并且工作时间也很长，但是我们会共享全部的成果，而第二家公司我们在合同里就定好了多劳多得的规矩。当然这不是我们今天讨论的重点。</p><p>如果我为一家大公司工作并且谈好了薪水，那我的预期就是我在标准的时间内，即公认的 (至少在美国) 一天 8 小时一周 5 天，尽我所能完成工作。如果他们希望我每周工作 70 个小时或有些主管期望团队每天都来上班，现在的我是会拒绝的。为什么呢？</p><p>当我们决定工作赚钱的时候，我们假定工作的主要原因是为了换取我们生活所需的开销。雇员的预期是他们会获得等价于这笔薪水的产出。但问题在于，雇主概念中的价值经常和雇员的不一样，尤其在美国和亚洲。许多公司期望薪水是固定的，但是他们创造这些价值需要完成的工作是不确定的。雇主觉得只要提高对雇员的预期和要求，就能够获得更大的回报，这样他们就可以通过为每份薪水延长工作时间来降低实质的劳动成本。</p><p>这对于雇员来说意味着什么？如果你同意了，那么你实际上就认同了自己的工作更廉价。甚至这种工作其实就是无偿的。那么作为雇员你在这样的无偿工作中收获了什么呢？在绝大多数雇主面前，你什么也没有得到。如果你是一个主管，也许会得到晋升，但是作为程序员你职业发展的道路不只是做管理这一条。如果你连续几个月每周编码超过 80 个小时，通常情况下得到的回报和一周努力工作 40 小时差不多。</p><a id="more"></a><p>在一些行业里，比如 AAA 游戏工作室，准备发布大型游戏这样的关键时刻的经历都是非常痛苦的。而你看了很多人们玩命工作然后发布没多久就下岗了的故事。当然你是可以选择休息的，但是付出的代价是多少？收益又是多少？</p><p>现在想象一下你自己是一个供应商 (我现在就是)。如果你要求在协议之上做更多的工作，那么公司付钱，供应商付出劳动。也许不会有更高的回报但不会比正常情况少。现在你是在为工作获取应有的回报。但奇怪之处在于，显然公司更倾向于根据时间付钱给你而不是你的实际产出，所以他们有的时候不会允许供应商加班。那他们为什么简单的要求雇员无偿工作或自告奋勇呢？</p><p>美国工人一般都有 10 天左右的年休假，有的时候还额外有几天病假；但是全职的美国工人评价一年只休息 5～7 天。在世界上很多地方，尤其是欧洲，政府<a href="http://dict.cn/mandates">授权</a> 20～30 天年假，人们基本上都会把这些假期用掉。在很多国家加班并不普遍，无偿加班是极少的，甚至是非法的。人们配得上工作之外的生活，对于他们来说，只为雇主埋头工作是<a href="http://dict.cn/unimaginably">极其</a>愚蠢的。而我们在美国 (以及亚洲很多地方) 很少这么思考问题。</p><p>我曾经有一个朋友，他的老板希望她的黑莓手机保持 24x7 待命状态。一年以后她拒绝并辞职了。她的老板为此<a href="http://dict.cn/livid">大为恼火</a>。而在那段时间她没有获得任何多余的回报。那我们为什么还这么做呢？</p><p>在欧美之间有一个很大的不同，美国的健康保险通常是和你的雇主绑定的，几乎没有其他地方给你<a href="http://dict.cn/virtually">实质的</a>保障。如果你失业了，那么你得在有限的时间里支付一大笔 (COBRA) 费用，即便你找到了一份新工作，你的健康保险在 6 个月内也没法生效。所以对失业的恐惧感以及健康保险会让你更倾向于接受更长的无偿工作时间。感觉这个系统设计之初就想阻止你跳来跳去 (尤其是你成家之后)。在欧洲你的健康保险不会和雇主做任何绑定。如果公司想留住一个有价值的员工，他们就得采取一些积极的措施把你<a href="http://dict.cn/entice">留</a>住。很多欧洲国家 (和欧元区) 你很难期待或要求别人无偿加班。</p><p>另外一个无偿加班的副作用是更少的人被雇佣。如果你长期让你的雇员每周工作 60～80 小时，你就不需要雇佣更多的人。但是对于雇员来说他们收获了什么呢？基本是没有什么收获的。</p><p>我想说的重点是，如果你付钱给我，那么我为你好好工作 40 小时，如果其他人愿意工作 60 或 80 小时，他们就更有价值而我就贬值了？我就应该由于没有把人生的全部都放在工作上而被解雇？那些愿意工作两倍时间的人就真的交付了两倍于我交付的价值吗？你可以反驳如果公司是根据工作时间给员工回报的，那么工作 80 小时的人就得到两倍回报，但这只是从雇主的角度来看。而雇员创造了更多的价值 (为公司带来了更多的收入) 但是没有得到任何更多的回报。当然你可以<a href="http://dict.cn/get%20rid%20of">无视</a>我，找到更多这样的公司，但是我对这种现代的“奴隶制”并<a href="http://dict.cn/unappealing">不感冒</a>。</p><p>工作不能也不应该是一个人的生活的全部，这绝对是欧洲式的思维。生活对我来说也意味着更多。然而在美国有一种非常商业化的观点，就是如果你根据工作时间付钱，那么公司就不会成功；如果人们每年要休假 20 天，那么他们就会失败；一个雇员工作之外的生活一文不值。</p><p>我从 Steve Jobs 听到的一个有意思的故事是，在 iPhone 装备的几周前 Steve 要求他们把塑料屏幕换成玻璃的，所以他们通知中国的工厂，那边立刻把上千名工人叫起来，每人发一块饼干一杯茶水，让他们每天连续工作 12 小时，直到 iPhone 装配好。真是一个神奇的故事，但同时也是一个悲伤的故事。他们如此轻易的放弃了生活 (我相信他们还是根据工作时间得到了报酬) 甚至乐在其中，就为了有份工作。而且我从雇主这里听到用这个故事来激励大家做相同的事情——“如果你每周不工作 80 个小时，那么在中国某些人就会顶替你的工作”。而企业会通过这些<a href="http://dict.cn/evoke">引起</a>笑声的国家取得成功。</p><p>经济是一门复杂的“科学”，我不想为此争辩太多。但是从一个个人工作者的角度看，就是一份付出一分回报。我有技能，公司有需求，我能作为一个有价值的工作者，但是这里是有度的。我不能对你或你的处境说什么，但是对我来说我的工作能力或工作期待是一个有限的范围。可能这是我的德国人的遗传，可能是因为我曾经在我的小公司每周工作 80 个小时的结果，可能我变老了也变聪明了，但是我更愿意享受工作和生活之间的平衡。</p><p>当我在 General Dynamics 的第一份工作时，我认识一位年轻的经理，他每周七天连续工作并且每天工作很长时间。有天在一个会上他突然猝死了。你说他没日没夜的工作最后得到了什么呢？</p><p>不为别人，也不为我自己。我努力工作，但到点该回家就会回家。你也应该这样。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;mark&gt;译自：&lt;a href=&quot;http://thecodist.com/article/why_i_don_39_t_do_unpaid_overtime_and_neither_should_you&quot;&gt;http://thecodist.com/article/why_i_don_39_t_do_unpaid_overtime_and_neither_should_you&lt;/a&gt;&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;原文写于 2012 年，至今已经有一段时间了，前段时间这篇文章又被大家翻出来热烈讨论，看过之后有些感触，所以翻译了一下&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;我是一个在美国待了 30 年的程序员，我有过一周工作超过 40 小时的经历，这在行业里面并不常见，但是我&lt;a href=&quot;http://dict.cn/rarely&quot;&gt;很难&lt;/a&gt;因此而得到更多的薪水。&lt;/p&gt;
&lt;p&gt;总之，我现在发现整个做法&lt;a href=&quot;http://dict.cn/nauseating&quot;&gt;很恶心&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;我并不是针对自营或创业等多干活儿就能得到更多回报的情况。我曾经在 80 年代中期到 90 年代开过两个小的软件公司，并且工作时间也很长，但是我们会共享全部的成果，而第二家公司我们在合同里就定好了多劳多得的规矩。当然这不是我们今天讨论的重点。&lt;/p&gt;
&lt;p&gt;如果我为一家大公司工作并且谈好了薪水，那我的预期就是我在标准的时间内，即公认的 (至少在美国) 一天 8 小时一周 5 天，尽我所能完成工作。如果他们希望我每周工作 70 个小时或有些主管期望团队每天都来上班，现在的我是会拒绝的。为什么呢？&lt;/p&gt;
&lt;p&gt;当我们决定工作赚钱的时候，我们假定工作的主要原因是为了换取我们生活所需的开销。雇员的预期是他们会获得等价于这笔薪水的产出。但问题在于，雇主概念中的价值经常和雇员的不一样，尤其在美国和亚洲。许多公司期望薪水是固定的，但是他们创造这些价值需要完成的工作是不确定的。雇主觉得只要提高对雇员的预期和要求，就能够获得更大的回报，这样他们就可以通过为每份薪水延长工作时间来降低实质的劳动成本。&lt;/p&gt;
&lt;p&gt;这对于雇员来说意味着什么？如果你同意了，那么你实际上就认同了自己的工作更廉价。甚至这种工作其实就是无偿的。那么作为雇员你在这样的无偿工作中收获了什么呢？在绝大多数雇主面前，你什么也没有得到。如果你是一个主管，也许会得到晋升，但是作为程序员你职业发展的道路不只是做管理这一条。如果你连续几个月每周编码超过 80 个小时，通常情况下得到的回报和一周努力工作 40 小时差不多。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>寄语应届生：走出校园的几个人生转变</title>
    <link href="https://jiongks.name//blog/for-after-college/"/>
    <id>https://jiongks.name//blog/for-after-college/</id>
    <published>2017-03-30T03:24:24.000Z</published>
    <updated>2017-03-30T03:40:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近收到个邀请，<a href="https://weibo.com/2724465062/ECaVuAyZk">有机会和大学生的在线互动交流</a>，体裁不限。我选了上面这个题目，整理了一些心得感想，虽然活动很快就结束了，但是这些想法我打算还是以文字形式备忘一下。如果能给更多人帮助或参考，我会倍感欣慰。</p><h3 id="目标的转变"><a href="#目标的转变" class="headerlink" title="目标的转变"></a>目标的转变</h3><p>作为学生，毫无疑问是以学业为重。在校园里，大家不出意外都会把学习定为最大的目标，围着功课转。但是工作之后，你可能面对很多事情要处理，怎么有所成就？怎么赚钱？怎么照顾好自己？怎么照顾好家庭……除了目标本身不同之外，我觉得更大的不一样在于，在相当长且连续的学生生涯中，我们没有太多选择的余地和必要，即便是有什么目标，也基本上是被动接受或被灌输的。但是走出校园之后，你面对的是一个无比自由开放的社会。这个时候你需要的不是意见，而是主见。甚至你是否做好了准备，有了足够的本事从事一项工作，还是继续学习深造修炼自我，直到自己准备好为止再工作？这也需要你的主见 (并为这个主见承担相应的后果，某种角度上)。最终很多选择是开放的，权衡的，遵从自己内心的结果。</p><p>还有一点我想说的是，因为你拥有了新的目标，而且不再会有人逼着你学习，从外部给你学习上的压力，所以客观上学习的环境也没有那么好那么纯粹了，学习这件事情会逐渐变得让你渴望、珍惜、喜欢。希望你还没有因为繁重的学业对新事物新知识，尤其是表面上枯燥但实际上对你有很多帮助的东西，失去动力。我们在校园里更多的是学习知识，然后推导这些知识可以用在什么地方；走出校园之后更多的需要思考，我遇到一个问题想解决它，究竟有多少知识哪些知识可以为我所用？也许在未来的某一天你会突然觉得，当时在校园里，学习环境那么好，怎么没有多看两本书，多做些训练。所以最好不要丢下自己看书学习的习惯，给自己定个长期的学习计划，有空就多看两本书。</p><h3 id="学会社交"><a href="#学会社交" class="headerlink" title="学会社交"></a>学会社交</h3><p>坦白地讲我觉得这在校园里并不是必备的技能。但是走出校园之后，它非常非常重要。这也是为什么几乎所有的公司都会给员工做沟通培训 (尽管那并不一定管用)。社交并不只是沟通而已，也不只是表达，更是聆听，是待人接物的每一个细节。我发现很多人在工作中，最简单的两件事情做不好，也不知道该怎么做，那就是：1 如何写邮件、2 如何开会。这表面上是职场礼数的范畴，也有很多文章介绍这些职场礼数，看上去就是个知识点罢了。但实际上一个人在理解和实践它的背后，反映的是修养，甚至是教养。这不是一两篇文章能够教会你的，是你平时为人处事方式的积累和感悟。</p><p>另外社交能力的重要性不止体现在工作中，体现在你步入社会之后可能会面对的各种场合的各种人，比如和同事下班之后一起组织些活动放松消遣一下，和老乡或老同学叙叙旧——这些也都是我刚毕业的时候经常会做的事情。但是这里我认为更重要的场景是：学会如何跟陌生人打交道，如何更主动的和陌生人交流，和这个社会交流。从最简单的跟陌生人问路、跟陌生的房东租房子、甚至搭讪对吧 ^_^，到跟不同性格的服务员、乘务员、售票员、公交车司机、出租车司机沟通或寻求帮助，再到你如何主动但又不会让对方和周围人尴尬的帮助别人，包括你是否会本能的路见不平挺身而出……抱歉这可能有点超出社交这个话题了。但这些都是有关联的不是吗？每个人在这个社会中都是一个独立的个体，但又是相互依赖相互依靠的一个集体社会。想真正融入这个社会，我觉得这些都是必须的。</p><p>最后，关于社交，还有一点很重要，就是在你刚刚加入一个公司或团队的时候，你周围的人一开始对你来说都是陌生人。这个社会上可能有很多适合你的机会，但它们不会主动找到你头上，这个时候需要你学会跟陌生人打交道。好的社交能力会让你的人生更有安全感，对自己办好一件事更有信心。和别人交流同样是一个完善自我认知的过程，尝试接受更多不同的观点，发现并理解不同的看问题的角度，有助于更认清自己，避免自以为是 (相信我，这种事情别人帮不上忙的，只能你自己领悟)。</p><h3 id="个人发展"><a href="#个人发展" class="headerlink" title="个人发展"></a>个人发展</h3><p>我觉得找工作这件事情，更多的要从兴趣出发，而不是所谓的“前途”。我逐渐越来越认同和相信一句老话：“三百六十行，行行出状元”。首先，如果对这件事情没有兴趣，你很难“用心”做好它，这样的状态也不是长久的；第二，我们已经看得见摸得着的“前途”和“机会”，往往已经不是什么好机会了，尤其是如今互联网时代事情变化发展这么快。而且那些真正抓住机会的人往往都是在完全没人看好的时候就开始全身心的投入在这个行业或方向上，才能在“机会”来临的时候抓住它，我不觉得这些人只是更厉害的“投机主义者”，如果没有兴趣在背后趋势着这些人，他们又是怎样才能在枯燥 (往往还伴随着高风险和不确定性) 的领域里这么坚定的做到今天呢？所以我的个人建议是，找工作，就完全追随自己的兴趣和内心就好了，不要想太多“这个行业比较赚钱比较有前途”之类的——它最多是你的一个参考项。找到自己的兴趣所在，相信它，相信自己，保持专注，一定有最好的回报，剩下的东西交给运(时)气(间)就好了。</p><p>再有就是要相信专业的力量，对学问保有“敬畏之心”。这里的学问不只是纯职业技术，也包括做事方式方法等等一切社科类的研究。<!--虽然我们看到今天很多行业存在这样一种不健康的现象：做 X 不赚钱，然后免费做 X 出了名，靠走穴之类的“不专注”来赚钱；再接下来大家发现 X 方面不专业也没关系，只要“出了名”，后面的“商演走穴赚钱”也行得通，而“出名”的方法又有很多，所以渐渐的没有人相信专业 X 的价值。我不知道这个 X 换成音乐、演技、技术之类的名次是不是都适用，但是这种成功只是少数个体的成功，而且是很短暂的，更重要的是这并不是一个行业和社会的成功。-->如果一个行业的专业性丢掉了，整个行业也就被毁掉了，最后大家会一起丢掉工作，一起失败。</p><p>这种东西我觉得跟很多已经被一份工作或长期不良型的环境所固化思想的“老家伙”们讲已经不一定有意义和效果了。但是对于打算或刚刚从校园步入社会，有理想，有抱负，承载着社会的未来的大学生们来说，我希望有机会在这方面多呼吁一下。尊重和相信专业的力量，耐得住性子，不要被一时的挫折、不走运或委屈左右，多多磨练自己，你一定不会后悔。</p><h3 id="So-Are-You-Ready？"><a href="#So-Are-You-Ready？" class="headerlink" title="So Are You Ready？"></a>So Are You Ready？</h3><p>：）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近收到个邀请，&lt;a href=&quot;https://weibo.com/2724465062/ECaVuAyZk&quot;&gt;有机会和大学生的在线互动交流&lt;/a&gt;，体裁不限。我选了上面这个题目，整理了一些心得感想，虽然活动很快就结束了，但是这些想法我打算还是以文字形式备忘一下。如果能给
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>[译]如果管理是唯一可走的路，那就完蛋了</title>
    <link href="https://jiongks.name//blog/if-management-is-the-only-way-up-we-are-all-fd/"/>
    <id>https://jiongks.name//blog/if-management-is-the-only-way-up-we-are-all-fd/</id>
    <published>2017-03-28T12:34:18.000Z</published>
    <updated>2017-08-01T02:58:36.000Z</updated>
    
    <content type="html"><![CDATA[<p><mark>译自：<a href="https://moz.com/rand/if-management-is-the-only-way-up-were-all-fd/">https://moz.com/rand/if-management-is-the-only-way-up-were-all-fd/</a></mark></p><p>注：作者 Rand 是 Moz 的 CEO，文中反复出现两个词：IC (Individual Contributor) 和 PW (People Wrangler)，分别翻译成了一线员工和经理人。</p><hr><p><a href="http://everywhereist.com/">Geraldine</a> 很喜欢她曾经在 Cranium 的工作 (西雅图的<a href="http://dict.cn/board%20game">桌游</a>初创公司，在 Hasbro 收购他们并<a href="http://dict.cn/layoffs">裁员</a><a href="http://dict.cn/prior">之前</a>)。她为桌游撰写问题，并为包装盒和营销材料撰写<a href="http://dict.cn/copy">文案</a>。她很擅长这个。但是发生了一些奇怪的事情——他们想让她晋升。我记得她晚上回家后<a href="http://dict.cn/endlessly">非常的</a><a href="http://dict.cn/fretting">苦恼</a>。她不想让人们向她汇报。她不想在团队中拥有更大的责任。她只想写写东西。</p><p>这很奇怪。当我们审视一家公司的结构时，很容易发现团队需要很多高质量的一线员工 (IC) 以及少数高质量的<a href="http://dict.cn/wrangler">经理人</a>。然而我们的<a href="http://dict.cn/corporate">公司</a>文化和这个世界的“模式”已经让我觉得除非你要带人，否则你的影响力、薪水、利益、职位和自我价值都不会增长。</p><p><a href="http://www.urbandictionary.com/define.php?term=I%20call%20bullshit">这都什么乱七八糟的。</a></p><p>我过去写过关于多样化成长轨迹的重要性——<a href="https://moz.com/rand/whats-the-right-team-structure/">一线员工和经理人</a>——但是我们最近在 Moz 花了大量的时间碰撞想法，很快会实施一个新的职位/团队的结构，最终付诸实践，我对此充满期待。</p><p>现在我会为一个在其工作岗位上做的很优秀的一线员工表达对管理的兴趣而担心。我担心这种渴望的很<a href="http://dict.cn/significant">重要的</a><a href="http://dict.cn/portion">一部分</a>不源自真正的管理责任感，而是因为他们想要在职业生涯和/或影响力上得到提高，并且认为这是唯一的办法。</p><p>我画了这张图来辅助<a href="http://dict.cn/illustrate">说明</a>两种角色之间的不同：</p><p><img src="https://images.sparktoro.com/blog/wp-content/uploads/2017/10/ics-vs-pws-small.gif" alt="ics-vs-pws-small"><br>(<a href="https://images.sparktoro.com/blog/wp-content/uploads/2017/10/ics-vs-pws-large.gif">大图</a>)</p><a id="more"></a><p>一线员工为他们自己及其工作负责。因为他们以一线员工的方式取得了长足的发展，所以他们的影响力变得更加广泛。一个在 Moz 的好的例子就是 <a href="http://www.seomoz.org/users/profile/22897">Dr. Pete</a>，他<a href="http://dict.cn/recognize">判断</a>公司的战略<a href="http://dict.cn/imperative">指示</a>并随之<a href="http://dict.cn/pitch%20in">协力投入</a>。他通过审查来协助大数据操作，通过<a href="http://dict.cn/tactical">战术</a>指导和策略输入来辅助市场，发表如此高质量的<a href="http://www.seomoz.org/blog/are-exact-match-domains-in-decline">博客</a>和<a href="http://www.seomoz.org/google-algorithm-change">指南</a>，甚至<a href="http://dict.cn/from%20the%20ground%20up">从头开始</a>设计<a href="http://mozcast.com/">整个项目</a>并基于他们的创意执行。他的影响遍及整个公司，横跨多个团队，和他们一同成长。他通过自己的影响力定义了这个角色，这比其它方式都好。</p><p><a href="https://translate.google.com/#en/zh-CN/on%20the%20flip%20side">另一方面</a>，优秀的经理人有义务让他们的团队开心、<a href="http://dict.cn/cohesion">团结</a>、<a href="http://dict.cn/empowerment">自主</a>，也要负责审查、指导等等。他们发展的越顺利，就越不需要“待在<a href="http://dict.cn/trench">壕沟</a>里”了。很多情况下，他们只会协助定义战略问题。剩下的定义范围、搜索相关答案、实现和执行统统都交给一线员工来做。一个在 Moz 的好的例子就是 <a href="http://www.seomoz.org/team/samantha">Samantha Britney</a>。她长期是一个一线员工，但现如今已经成为了经理人，帮助产品团队的几个一线员工，给予他们工作的自主性，通过工具、资源和协助把事做好，并提供作为一个经理人必要的辅导、一对一、回顾和 HR 工作。她的报告中从不会提及任何细枝末节，但总会驱动他们的项目向前。</p><p>基本上，如果你喜欢并且能够把这件事做好，那么你应该做一个一线员工。如果你喜欢 (且擅长) 把自主权交给其他人，帮助他们成长和成功，那么你应该做一个经理人。</p><p>这些一线员工和经理人之间有这样一些<a href="http://dict.cn/nuance">差别</a>：</p><ul><li>随着一线员工们的发展，他们希望和经理人的职责范围有更多的重叠。对经理人来说恰恰相反——随着他们的发展，他们实际干的活越来越少。</li><li>资深的一线员工的角色更加灵活——他们能够在各种地方工作，并且由于工作得到<a href="http://dict.cn/recognition">认可</a>，收到的会议和活动邀约就越来越多。资深的经理人相反——他们在办公室的时间更为<a href="http://dict.cn/critical">关键</a>，所以很少出差，也经常<a href="http://dict.cn/behind-the-scenes">身居幕后</a> (<a href="http://dict.cn/notable">很明显</a> CEO 在这方面是一个例外)。</li><li>如果你有很多一线员工却只有很少的经理人，那么你会发现汇报和管理很有挑战。但是如果你有一堆经理人而没几个一线员工，你会<a href="http://dict.cn/horrify">面临</a>“厨师太多伙计不够了”的问题 (并且这通常意味着你们的组织和文化已经一团糟了)。</li><li>优秀的一线员工有时会发展成为经理人，并因此在新的角色上变得<a href="http://dict.cn/mediocre">平庸</a>或失败。这绝对是个悲剧。公司不仅失去了一个卓越的一线员工，而且连管理也被搞砸了，因为这会造成大量<a href="http://dict.cn/viral">传染式</a>的问题。<a href="https://translate.google.com/#en/zh-CN/on%20the%20flip%20side">而</a>如果一个一线员工<a href="http://dict.cn/underperforming">表现平平</a>，问题往往不至于这么严重。</li><li><a href="http://dict.cn/compensation">待遇</a>是个技巧活儿。在我理想的世界里 (对了我们在 Moz 创建的工资范围是跨发展路线的)，一线员工和经理人的级别是<a href="http://dict.cn/roughly">大致</a><a href="http://dict.cn/equivalent">等价的</a>。假设在某一条路线上有 7 个级别，那么 level 3 的一线员工可以做 level 3 的经理人的事情。最高级别的一线员工应该能够和 CXO 挣得一样多。</li></ul><p>我和他人分享这些观点时，大部分情况是<a href="http://dict.cn/intuitive">直观的</a>。我遇到过的最大问题和一个简单的概念有关——战略战术的所有权。有一天一个 Mozzer 同事和我在这方面的看法就不一致。他觉得在 Moz 的历史上，有些团队的经理人掌握着战略和战术的所有权。个人开发者没有定义他们做什么，怎么做，如何衡量，也没有定义执行过程，他们只是接受命令。</p><p>是的这样做也行得通并且这种情况确实发生过。但是我不同意我的同事，这样做相比于，把更大的所有权交给一线员工，让他们决定做什么、何时何地、如何做，让经理人指决定谁来做已经为什么要做，效果不可能一样。<a href="http://dict.cn/Granted">诚然</a>，很多初级经理人和一线员工之间会具有更大的内容重叠，而很多高级个人开发者会决定谁来做和为什么要做 (如上所述)。但是我强烈的相信，从长期来看，我们应该走这条路。人们的快乐便在此之上。</p><p>当 Daniel Pink 问道<a href="http://www.danpink.com/drive-the-summaries">“是什么让我们的工作快乐？”</a>时，答案已经很明显 (并且被很多其他学者和不太正式调查者证实)：</p><ol><li>自治——主导我们自己生活的渴望。</li><li>精通——在关键的事情上越做越好的欲望。</li><li>目的——渴望做好比我们自己更重要的事情</li></ol><p>如果个人开发者无法控制自己的工作内容并且能够掌握工作技能，他们中间优秀的人就会离开，去那些提供这种机会的公司。我们将只留下经理人，而且这会很快。</p><p>很奇怪，我是那种一线员工风格的 CEO (也许这并不都是奇怪)。我是一个高级别的一线员工，所以我和经理人有很大的职责重叠，但是我会服务所有的团队、工作和细节。我可能是最直接参与到产品和市场的人，我也经常让这些团队 Mozzer 们像对待资源和工具一样对待我。你让我写篇博客我就会去写，你让我答复一个客户我就会冲上去，你需要聊聊一个项目如何匹配更广泛的目标，以及如何改变你的做法，那就一起聊聊呗。我喜欢我汇报给这些 Moz 员工的感觉——而不是其它方式。我想这件事情永远也不会改变。</p><p>p.s. 我很喜欢 <a href="http://themassesareangry.blogspot.com/2011/05/on-virtues-of-being-individual.html">Phil Scarr 的这篇文章</a>，它描述了自己从经理人转变为一线员工的经历以及为什么。<a href="http://www.seomoz.org/team/carin">Carin</a> 从带领着我们的大数据团队，转变为一个产品团队的资深一线员工，我为之感到骄傲。</p><p>p.p.s. 如果我的思路不对 (或者对) 而你也有相关的经验，不妨也留言给我。我一定虚心学习——因为我一直在提醒自己，我是第一次当 CEO </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;mark&gt;译自：&lt;a href=&quot;https://moz.com/rand/if-management-is-the-only-way-up-were-all-fd/&quot;&gt;https://moz.com/rand/if-management-is-the-only-way-up-were-all-fd/&lt;/a&gt;&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;注：作者 Rand 是 Moz 的 CEO，文中反复出现两个词：IC (Individual Contributor) 和 PW (People Wrangler)，分别翻译成了一线员工和经理人。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href=&quot;http://everywhereist.com/&quot;&gt;Geraldine&lt;/a&gt; 很喜欢她曾经在 Cranium 的工作 (西雅图的&lt;a href=&quot;http://dict.cn/board%20game&quot;&gt;桌游&lt;/a&gt;初创公司，在 Hasbro 收购他们并&lt;a href=&quot;http://dict.cn/layoffs&quot;&gt;裁员&lt;/a&gt;&lt;a href=&quot;http://dict.cn/prior&quot;&gt;之前&lt;/a&gt;)。她为桌游撰写问题，并为包装盒和营销材料撰写&lt;a href=&quot;http://dict.cn/copy&quot;&gt;文案&lt;/a&gt;。她很擅长这个。但是发生了一些奇怪的事情——他们想让她晋升。我记得她晚上回家后&lt;a href=&quot;http://dict.cn/endlessly&quot;&gt;非常的&lt;/a&gt;&lt;a href=&quot;http://dict.cn/fretting&quot;&gt;苦恼&lt;/a&gt;。她不想让人们向她汇报。她不想在团队中拥有更大的责任。她只想写写东西。&lt;/p&gt;
&lt;p&gt;这很奇怪。当我们审视一家公司的结构时，很容易发现团队需要很多高质量的一线员工 (IC) 以及少数高质量的&lt;a href=&quot;http://dict.cn/wrangler&quot;&gt;经理人&lt;/a&gt;。然而我们的&lt;a href=&quot;http://dict.cn/corporate&quot;&gt;公司&lt;/a&gt;文化和这个世界的“模式”已经让我觉得除非你要带人，否则你的影响力、薪水、利益、职位和自我价值都不会增长。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.urbandictionary.com/define.php?term=I%20call%20bullshit&quot;&gt;这都什么乱七八糟的。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我过去写过关于多样化成长轨迹的重要性——&lt;a href=&quot;https://moz.com/rand/whats-the-right-team-structure/&quot;&gt;一线员工和经理人&lt;/a&gt;——但是我们最近在 Moz 花了大量的时间碰撞想法，很快会实施一个新的职位/团队的结构，最终付诸实践，我对此充满期待。&lt;/p&gt;
&lt;p&gt;现在我会为一个在其工作岗位上做的很优秀的一线员工表达对管理的兴趣而担心。我担心这种渴望的很&lt;a href=&quot;http://dict.cn/significant&quot;&gt;重要的&lt;/a&gt;&lt;a href=&quot;http://dict.cn/portion&quot;&gt;一部分&lt;/a&gt;不源自真正的管理责任感，而是因为他们想要在职业生涯和/或影响力上得到提高，并且认为这是唯一的办法。&lt;/p&gt;
&lt;p&gt;我画了这张图来辅助&lt;a href=&quot;http://dict.cn/illustrate&quot;&gt;说明&lt;/a&gt;两种角色之间的不同：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.sparktoro.com/blog/wp-content/uploads/2017/10/ics-vs-pws-small.gif&quot; alt=&quot;ics-vs-pws-small&quot;&gt;&lt;br&gt;(&lt;a href=&quot;https://images.sparktoro.com/blog/wp-content/uploads/2017/10/ics-vs-pws-large.gif&quot;&gt;大图&lt;/a&gt;)&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>[译]如何撰写 Git 提交信息</title>
    <link href="https://jiongks.name//blog/git-commit/"/>
    <id>https://jiongks.name//blog/git-commit/</id>
    <published>2017-03-20T03:28:05.000Z</published>
    <updated>2017-08-18T03:42:17.000Z</updated>
    
    <content type="html"><![CDATA[<p><mark>译自：<a href="https://chris.beams.io/posts/git-commit/">https://chris.beams.io/posts/git-commit/</a></mark></p><hr><p><img src="https://imgs.xkcd.com/comics/git_commit.png" alt=""></p><h3 id="介绍：为什么好的提交信息非常重要"><a href="#介绍：为什么好的提交信息非常重要" class="headerlink" title="介绍：为什么好的提交信息非常重要"></a>介绍：为什么好的提交信息非常重要</h3><p>如果你浏览任何 Git 仓库的日志，你可能会发现那些提交信息多少有些<a href="http://dict.cn/mess">混乱</a>。比如，看看这些我早年提交给 Spring 的<a href="https://github.com/spring-projects/spring-framework/commits/e5f4b49?author=cbeams">精品</a>：</p><pre><code>$ git log --oneline -5 --author cbeams --before &quot;Fri Mar 26 2009&quot;e5f4b49 Re-adding ConfigurationPostProcessorTests after its brief removal in r814. @Ignore-ing the testCglibClassesAreLoadedJustInTimeForEnhancement() method as it turns out this was one of the culprits in the recent build breakage. The classloader hacking causes subtle downstream effects, breaking unrelated tests. The test method is still useful, but should only be run on a manual basis to ensure CGLIB is not prematurely classloaded, and should not be run as part of the automated build.2db0f12 fixed two build-breaking issues: + reverted ClassMetadataReadingVisitor to revision 794 + eliminated ConfigurationPostProcessorTests until further investigation determines why it causes downstream tests to fail (such as the seemingly unrelated ClassPathXmlApplicationContextTests)147709f Tweaks to package-info.java files22b25e0 Consolidated Util and MutableAnnotationUtils classes into existing AsmUtils7f96f57 polishing</code></pre><p><a href="http://dict.cn/Yikes">呀</a>，比较一下这个仓库<a href="https://github.com/spring-projects/spring-framework/commits/5ba3db?author=philwebb">最近的提交</a>：</p><pre><code>$ git log --oneline -5 --author pwebb --before &quot;Sat Aug 30 2014&quot;5ba3db6 Fix failing CompositePropertySourceTests84564a0 Rework @PropertySource early parsing logice142fd1 Add tests for ImportSelector meta-data887815f Update docbook dependency and generate epubac8326d Polish mockito usage</code></pre><p>你更喜欢读哪个呢？</p><a id="more"></a><p>过去的信息从长度到形式都很多样；最近的信息比较简洁且一致。过去的信息是一般情况下会发生的；最近的信息绝不是<a href="http://dict.cn/by%20accident">偶然</a>发生。</p><p>虽然很多仓库的日志看起来像是过去的，但也有例外。Linux 内核和 Git 自身就是伟大的例子。再比如 Spring Boot 或其它由 Tim Pope 管理的仓库。</p><p>这些仓库的贡献者知道，对于一个开发同事来说 (其实对未来的<a href="http://dict.cn/selves">自己</a>也是一样)，一条用心撰写的 Git 提交信息是用来沟通这则改动最好的上下文。一个 diff 会告诉你<em>什么</em>改变了，但是只有提交信息能<a href="http://dict.cn/properly">正确的</a>告诉你<em>为什么</em>。Peter Hutterer 阐述得非常好：</p><blockquote><p>重建一段代码的上下文是非常费时费力的，这是无法完全避免的。所以我们应该努力尽可能的<a href="http://www.osnews.com/story/19266/WTFs_m">减少它</a>。提交信息可以帮上这个忙，也正因为此，一个提交信息反应了一名开发者是不是个好的协作者。</p></blockquote><p>如果你对于创建一个伟大的提交信息还没有想过太多，那说明你可能还没有在 <code>git log</code> 及相关的工具上花费太多的时间。这里有一个<a href="http://dict.cn/vicious">恶性</a>循环：因为提交历史不成体系且不一致，我们就不会花更多的时间使用和关心它。因为它得不到使用和关注，所以它就一直不成体系且不一致。</p><p>但是用心写出来的日志是美丽且实用的。<code>git blame</code>、<code>revert</code>、<code>rebase</code>、<code>log</code>、<code>shortlog</code> 以及其它子命令就是生命的一部分。回顾其他人的提交和 pull requests 变成了值得去做的事情，并且可以快速独立完成。理解最近几个月或几年为什么发生了这些事情不止是可能的并且是<a href="http://dict.cn/efficient">高效的</a>。</p><p>一个项目的长期成功<a href="http://dict.cn/rest%20on">靠的是</a>其可维护性，以及一个拥有比项目的日志更强大的工具的维护者。这里值得花时间学习一下如何<a href="http://dict.cn/properly">正确的</a>考虑它。一开始可能是个<a href="http://dict.cn/hassle">麻烦</a>的东西很快会变成习惯，并且最终变成一切<a href="http://dict.cn/involved">投入</a>的自豪和<a href="http://dict.cn/productivity">产能</a>的源泉。</p><p>在这篇文章中，我只会<a href="http://dict.cn/addressing">致力于</a>保障一个健康的提交历史的最基本要素：如何撰写一份个人提交信息。这里还有其它重要的实践比如<a href="http://dict.cn/squashing">压缩</a>提交 (commit squashing) 就不是我在这里想说的。可能会为此<a href="http://dict.cn/subsequent">再</a>写一篇吧。</p><p>大多数编程语言都建立了良好的编码规约，以<a href="http://dict.cn/constitutes">形成</a><a href="http://dict.cn/idiomatic">惯用</a>的风格，比如命名、格式化等。当然在这些编码规约中有一些<a href="http://dict.cn/variations">差异</a>，但是大多数开发者赞同取其一并养成习惯好过每个人都选择自己的风格而<a href="http://dict.cn/ensues">发生</a>混乱。</p><p>一个团队的提交日志方法应该是一致的。为了建立一个有用的<a href="http://dict.cn/revision">修订</a>历史，团队应该首先约定一个提交信息的规约，该规约至少定义以下三方面：</p><p><strong>样式。</strong>标记<a href="http://dict.cn/syntax">句法</a>、缠绕边距、<a href="http://dict.cn/grammar">语法</a>、<a href="http://dict.cn/capitalization">大小写</a>、<a href="http://dict.cn/punctuation">标点符号</a>。把这些东西都找出来，去除猜测，把规则定的尽量简单可行。最终的产出将会是<a href="http://dict.cn/remarkably">不同寻常的</a>一致的日志，不只是乐于阅读，实际上也让阅读变成了一种<a href="http://dict.cn/on%20a%20regular%20basis">习惯</a>。</p><p><strong>内容。</strong>提交信息的正文 (body) (如有) 应该包含什么样的信息？不应该包含什么？</p><p><strong>元数据。</strong>Issue 追踪 ID、pull request 号等信息如何放进来？</p><p>幸运的是，这里有一些已经被良好建立的规约，用来创建<a href="http://dict.cn/idiomatic">惯用的</a> Git 提交信息。<a href="http://dict.cn/indeed">事实上</a>，有些规约中很多都是以某种 Git 命令的方式工作的。不需要你重新发明任何东西。只需遵循下面七大法则，你就可以像专家一样进行提交：</p><h3 id="伟大的-Git-提交信息七大法则"><a href="#伟大的-Git-提交信息七大法则" class="headerlink" title="伟大的 Git 提交信息七大法则"></a>伟大的 Git 提交信息七大法则</h3><blockquote><p>注意：<a href="http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html">这些</a> <a href="https://www.git-scm.com/book/en/Distributed-Git-Contributing-to-a-Project#Commit-Guidelines">法则</a> <a href="https://github.com/torvalds/subsurface/blob/master/README#L82-109">之前</a> <a href="http://who-t.blogspot.co.at/2009/12/on-commit-messages.html">在别的地方</a> <a href="https://github.com/erlang/otp/wiki/writing-good-commit-messages">也</a> <a href="https://github.com/spring-projects/spring-framework/blob/30bce7/CONTRIBUTING.md#format-commit-messages">提到过</a>。</p></blockquote><ol><li>用一个空行把主题和主题隔离开</li><li>把主题行限制在 50 个字符以内</li><li>主题行大写开头</li><li>主题行不必以句号结尾</li><li>在主题行中使用<a href="http://dict.cn/imperative">祈使句</a></li><li>正文在 72 个字符处折行</li><li>使用正文解释<em>是什么</em>和<em>为什么</em>而不是<em>怎么样</em></li></ol><p>比如：</p><pre><code>Summarize changes in around 50 characters or lessMore detailed explanatory text, if necessary. Wrap it to about 72characters or so. In some contexts, the first line is treated as thesubject of the commit and the rest of the text as the body. Theblank line separating the summary from the body is critical (unlessyou omit the body entirely); various tools like `log`, `shortlog`and `rebase` can get confused if you run the two together.Explain the problem that this commit is solving. Focus on why youare making this change as opposed to how (the code explains that).Are there side effects or other unintuitive consequences of thischange? Here&apos;s the place to explain them.Further paragraphs come after blank lines. - Bullet points are okay, too - Typically a hyphen or asterisk is used for the bullet, preceded   by a single space, with blank lines in between, but conventions   vary hereIf you use an issue tracker, put references to them at the bottom,like this:Resolves: #123See also: #456, #789</code></pre><h4 id="1-用一个空行把主题和正文隔离开"><a href="#1-用一个空行把主题和正文隔离开" class="headerlink" title="1. 用一个空行把主题和正文隔离开"></a>1. 用一个空行把主题和正文隔离开</h4><p>在 <code>git commit</code> 的 manpage 手册中写到：</p><blockquote><p>虽然不是必须的，但是你最好以一句少于 50 个字符的话简短概括你的改动，然后空一行，再深入描述。提交信息中空行之上的文本会被当作提交的标题，该标题在 Git 中到处都会用到。比如 Git-format-patch(1) 会把一个提交转换为一封电子邮件，它会把这个标题作为邮件的主题，其余的部分会作为邮件的正文。</p></blockquote><p>首先，不是每一次提交都同时需要一个主题和一段正文。有的时候单独一行就可以了，尤其是当改动很简单没有更多必要的上下文的时候。比如：</p><pre><code>Fix typo in introduction to user guide</code></pre><p>无需说更多；如果读者好奇到底修复了什么 typo，她可以通过诸如 <code>git show</code> 或 <code>git diff</code> 或 <code>git log -p</code> 简单看看改动的内容就可以了。</p><p>如果你是在命令行中提交，则很容易使用 <code>git commit</code> 的 <code>-m</code> 选项：</p><pre><code>$ git commit -m&quot;Fix typo in introduction to user guide&quot;</code></pre><p>然而，当一个提交<a href="http://dict.cn/merits">值得</a>一些解释和上下文的时候，你需要撰写正文。比如：</p><pre><code>Derezz the master control programMCP turned out to be evil and had become intent on world domination.This commit throws Tron&apos;s disc into MCP (causing its deresolution)and turns it back into a chess game.</code></pre><p>带正文的提交信息并不便于通过 <code>-m</code> 选项来撰写。你最好找一个合适的文本编辑器撰写信息。如果你并没有在命令行中为 Git 设置过编辑器，那么请移步阅读 <a href="https://git-scm.com/book/en/v2/Customizing-Git-Git-Configuration">Pro Git 的这个章节</a>。</p><p>当你在任何情况下浏览日志的时候，都会觉得把主题从正文中分离出来是<a href="http://dict.cn/pay%20off">值得的</a>。这里有一整段日志：</p><pre><code>$ git logcommit 42e769bdf4894310333942ffc5a15151222a87beAuthor: Kevin Flynn &lt;kevin@flynnsarcade.com&gt;Date:   Fri Jan 01 00:00:00 1982 -0200 Derezz the master control program MCP turned out to be evil and had become intent on world domination. This commit throws Tron&apos;s disc into MCP (causing its deresolution) and turns it back into a chess game.</code></pre><p>现在运行 <code>git log --oneline</code>，这个命令只会打印主题行：</p><pre><code>$ git log --oneline42e769 Derezz the master control program</code></pre><p>或者，<code>git shortlog</code>，这个命令会把提交按照用户分组，同样出于<a href="http://dict.cn/concision">简洁</a>的考虑只会打印主题行：</p><pre><code>$ git shortlogKevin Flynn (1):      Derezz the master control programAlan Bradley (1):      Introduce security program &quot;Tron&quot;Ed Dillinger (3):      Rename chess program to &quot;MCP&quot;      Modify chess program      Upgrade chess programWalter Gibbs (1):      Introduce protoype chess program</code></pre><p>在 Git 里还有一些其它的情况下，会<a href="http://dict.cn/distinction">区分</a>主题行和正文——但是如果没有它们中间的空行的话是不会<a href="http://dict.cn/properly">正常</a>工作的。</p><h4 id="2-把主题行限制在-50-个字符以内"><a href="#2-把主题行限制在-50-个字符以内" class="headerlink" title="2. 把主题行限制在 50 个字符以内"></a>2. 把主题行限制在 50 个字符以内</h4><p>50 个字符并不是一个严格的限制，只是个<a href="http://dict.cn/rule%20of%20thumb">经验之谈</a>。保持主题行的长度以确保它可读且促使作者考虑一下最<a href="http://dict.cn/concise">简略</a>的表达方式足矣。</p><blockquote><p>提示：如果你做总结很艰难，你可能是一次性提交太多东西了。把原子提交从中剥离出来吧 (每个主题是一个独立的提交)。</p></blockquote><p>GitHub 的 UI 都会提醒这些规约。如果你输入超过 50 个字符的限制，它会警告：</p><p><img src="https://i.imgur.com/zyBU2l6.png" alt="gh1"></p><p>而且会主题行超过 75 个字符的部分会被截断，留下一个省略号：</p><p><img src="https://i.imgur.com/27n9O8y.png" alt="gh2"></p><p>所以奔着 50 个字符去写，但是 72 个字符是底线。</p><h4 id="3-主题行大写开头"><a href="#3-主题行大写开头" class="headerlink" title="3. 主题行大写开头"></a>3. 主题行大写开头</h4><p>如题。比如：</p><ul><li>Accelerate to 88 miles per hour</li></ul><p>而不是：</p><ul><li>accelerate to 88 miles per hour</li></ul><h4 id="4-主题行不必以句号结尾"><a href="#4-主题行不必以句号结尾" class="headerlink" title="4. 主题行不必以句号结尾"></a>4. 主题行不必以句号结尾</h4><p>主题行结尾的标点<a href="http://dict.cn/punctuation">符号用法</a>不是必要的。而且，当你打算控制在 50 个字符以内时，连空格都是<a href="http://dict.cn/precious">很宝贵的</a>。比如：</p><ul><li>Open the pod bay doors</li></ul><p>而不是：</p><ul><li>Open the pod bay doors.</li></ul><h4 id="5-在主题行中使用祈使句"><a href="#5-在主题行中使用祈使句" class="headerlink" title="5. 在主题行中使用祈使句"></a>5. 在主题行中使用<a href="http://dict.cn/imperative">祈使句</a></h4><p><em><a href="http://dict.cn/imperative">祈使句</a></em>就是指“说起来或写起来像是在发号施令”。举几个例子：</p><ul><li>Clean your room</li><li>Close the door</li><li>Take out the trash</li></ul><p>其实这七大法则的每一条读起来都是<a href="http://dict.cn/imperative">祈使句</a>的 (“正文在 72 个字符处折行”等)。</p><p><a href="http://dict.cn/imperative">祈使句</a>听起来有一点粗鲁；这也是我们为什么不常用它的原因。但是这非常适合写在 Git 提交的主题行中。其中一个的原因就是 <strong>Git 本身就是根据你的意志<a href="http://dict.cn/imperative">命令式</a>的创建一个提交的</strong>。</p><p>例如，使用 <code>git merge</code> 的默认信息读起来是这样的：</p><pre><code>Merge branch &apos;myfeature&apos;</code></pre><p>而用 <code>git revert</code> 的时候是：</p><pre><code>Revert &quot;Add the thing with the stuff&quot;This reverts commit cc87791524aedd593cff5a74532befe7ab69ce9d.</code></pre><p>再或者在一个 GitHub pull request 上点击“Merge”按钮时：</p><pre><code>Merge pull request #123 from someuser/somebranch</code></pre><p>所以当你以<a href="http://dict.cn/imperative">祈使句</a>撰写你的提交信息时，你遵循了 Git 自己内建的规约。比如：</p><ul><li>Refactor subsystem X for readability</li><li>Update getting started documentation</li><li>Remove deprecated methods</li><li>Release version 1.0.0</li></ul><p>这样撰写一开始会觉得有点<a href="http://dict.cn/awkward">怪怪的</a>。我们更多的在说话的时候使用<a href="http://dict.cn/indicative">陈述句</a>来陈述事实。这是为什么提交信息经常读起来像：</p><ul><li>Fixed bug with Y</li><li>Changing behavior of X</li></ul><p>有的时候提交信息写起来像是对于其内容的描述：</p><ul><li>More fixes for broken stuff</li><li>Sweet new API methods</li></ul><p>为了避免混淆，这里有一个简单原则，可以用在每一个地方。</p><p><strong>一个 Git 提交的主题行的准确的格式应该始终完全遵循下面的句式：</strong></p><ul><li>If applied, this commit will <em>这里是你的主题行</em></li></ul><p>比如：</p><ul><li>If applied, this commit will <em>refactor subsystem X for readability</em></li><li>If applied, this commit will <em>update getting started documentation</em></li><li>If applied, this commit will <em>remove deprecated methods</em></li><li>If applied, this commit will <em>release version 1.0.0</em></li><li>If applied, this commit will <em>merge pull request #123 from user/branch</em></li></ul><p>注意<a href="http://dict.cn/imperative">非祈使句</a>在这里别扭的地方：</p><ul><li>If applied, this commit will <em>fixed bug with Y</em></li><li>If applied, this commit will <em>changing behavior of X</em></li><li>If applied, this commit will <em>more fixes for broken stuff</em></li><li>If applied, this commit will <em>sweet new API methods</em></li></ul><blockquote><p>注意：使用祈使句只在主题行中至关重要。当你撰写正文的时候就可以放下这些限制了。</p></blockquote><h4 id="6-正文在-72-个字符处折行"><a href="#6-正文在-72-个字符处折行" class="headerlink" title="6. 正文在 72 个字符处折行"></a>6. 正文在 72 个字符处折行</h4><p>Git 不会自动给文本折行。当你为一个提交撰写消息正文的时候，你必须意识到它正确的边距，并且手动折行。</p><p>这里推荐在 72 个字符处折行，这样 Git 有足够的空间，即便缩进文本也可以保证所有东西在 80 个字符以内。</p><p>一个好的文本编辑器是可以帮上忙的。比如在 Vim 中配置在 Git 提交的 72 个字符处折行非常容易。然而传统的 IDE 在给提交信息文本折行方面提供的智能支持<a href="http://dict.cn/terrible">很糟糕</a> (尽管 IntelliJ IDEA 在最近的版本中终于在这方面做得好一些了)。</p><h4 id="7-使用正文解释是什么和为什么而不是怎么样"><a href="#7-使用正文解释是什么和为什么而不是怎么样" class="headerlink" title="7. 使用正文解释是什么和为什么而不是怎么样"></a>7. 使用正文解释是什么和为什么而不是怎么样</h4><p>这个<a href="https://github.com/bitcoin/bitcoin/commit/eb0b56b19017ab5c16c745e6da39c53126924ed6">来自比特币核心的提交</a>是一个非常好的解释改动是什么和为什么的例子：</p><pre><code>commit eb0b56b19017ab5c16c745e6da39c53126924ed6Author: Pieter Wuille &lt;pieter.wuille@gmail.com&gt;Date:   Fri Aug 1 22:57:55 2014 +0200   Simplify serialize.h&apos;s exception handling   Remove the &apos;state&apos; and &apos;exceptmask&apos; from serialize.h&apos;s stream   implementations, as well as related methods.   As exceptmask always included &apos;failbit&apos;, and setstate was always   called with bits = failbit, all it did was immediately raise an   exception. Get rid of those variables, and replace the setstate   with direct exception throwing (which also removes some dead   code).   As a result, good() is never reached after a failure (there are   only 2 calls, one of which is in tests), and can just be replaced   by !eof().   fail(), clear(n) and exceptions() are just never called. Delete   them.</code></pre><p>看一眼<a href="https://github.com/bitcoin/bitcoin/commit/eb0b56b19017ab5c16c745e6da39c53126924ed6">完整的 diff</a>，想一下作者此时此刻通过提供这样的上下文为同事以及未来的提交者节省了多少时间。如果他不这样做，这些信息可能永远找不回来了。</p><p>在很多情况下，你可以<a href="http://dict.cn/leave%20out">忽略</a>这个改动发生时的各种细节。从这个角度看，代码自己会说话 (如果代码很复杂以至于需要长篇大论的解释，那也是代码注释该做的事情)。请首先专注于弄清你产生这个改动的理由——改动前的工作方式，改动后的工作方式 (以及这样做哪里不对)，以及为什么你决定以这样的方式解决问题。</p><p>你将来某一天维护它的时候也许会感激今天的你！</p><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><h4 id="学着爱上命令行。远离-IDE。"><a href="#学着爱上命令行。远离-IDE。" class="headerlink" title="学着爱上命令行。远离 IDE。"></a>学着爱上命令行。远离 IDE。</h4><p>[和 Git 子命令同样多的原因][For-as-many-reasons-at-there-are-Git-subcommands]，拥抱命令行是<a href="http://dict.cn/wise">明智</a>的。Git 是<a href="http://dict.cn/insanely">超级</a>强大的；IDE 也一样，但是套路不同。我每天都使用 IDE (IntelliJ IDEA) 也用过<a href="http://dict.cn/extensively">很多</a>其它的 (Eclipse)，但是我从未见到 IDE 对 Git 的集成能够配得上命令行的易用和强大 (一旦你意识到这一点)。</p><p>某些 Git 相关的 IDE 功能是<a href="http://dict.cn/invaluable">非常宝贵的</a>，比如当你删除一个文件时调用 <code>git rm</code>、当你重命名一个文件时完成相应的 <code>git</code> 命令。但是当你尝试提交、合并、rebase、或通过 IDE 做<a href="http://dict.cn/sophisticated">复杂的</a>历史分析时，事情就<a href="http://dict.cn/fall%20apart">分崩离析</a>了。</p><p>当你想<a href="http://dict.cn/wielding">发挥出</a> Git 全部的能量的时候，命令行始终是不二之选。</p><p>记住不论你是用的是 Bash 还是 Z shell，都有 <a href="http://git-scm.com/book/en/Git-Basics-Tips-and-Tricks">tab 补全脚本</a>减轻忘记子命令和开关的痛苦。</p><h4 id="阅读-Pro-Git"><a href="#阅读-Pro-Git" class="headerlink" title="阅读 Pro Git"></a>阅读 Pro Git</h4><p><a href="http://git-scm.com/book">Pro Git</a> 这本书已经可以免费在线阅读，这本书非常棒。<a href="http://dict.cn/take%20advantage">用好它吧</a>！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;mark&gt;译自：&lt;a href=&quot;https://chris.beams.io/posts/git-commit/&quot;&gt;https://chris.beams.io/posts/git-commit/&lt;/a&gt;&lt;/mark&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://imgs.xkcd.com/comics/git_commit.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;介绍：为什么好的提交信息非常重要&quot;&gt;&lt;a href=&quot;#介绍：为什么好的提交信息非常重要&quot; class=&quot;headerlink&quot; title=&quot;介绍：为什么好的提交信息非常重要&quot;&gt;&lt;/a&gt;介绍：为什么好的提交信息非常重要&lt;/h3&gt;&lt;p&gt;如果你浏览任何 Git 仓库的日志，你可能会发现那些提交信息多少有些&lt;a href=&quot;http://dict.cn/mess&quot;&gt;混乱&lt;/a&gt;。比如，看看这些我早年提交给 Spring 的&lt;a href=&quot;https://github.com/spring-projects/spring-framework/commits/e5f4b49?author=cbeams&quot;&gt;精品&lt;/a&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git log --oneline -5 --author cbeams --before &amp;quot;Fri Mar 26 2009&amp;quot;

e5f4b49 Re-adding ConfigurationPostProcessorTests after its brief removal in r814. @Ignore-ing the testCglibClassesAreLoadedJustInTimeForEnhancement() method as it turns out this was one of the culprits in the recent build breakage. The classloader hacking causes subtle downstream effects, breaking unrelated tests. The test method is still useful, but should only be run on a manual basis to ensure CGLIB is not prematurely classloaded, and should not be run as part of the automated build.
2db0f12 fixed two build-breaking issues: + reverted ClassMetadataReadingVisitor to revision 794 + eliminated ConfigurationPostProcessorTests until further investigation determines why it causes downstream tests to fail (such as the seemingly unrelated ClassPathXmlApplicationContextTests)
147709f Tweaks to package-info.java files
22b25e0 Consolidated Util and MutableAnnotationUtils classes into existing AsmUtils
7f96f57 polishing
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href=&quot;http://dict.cn/Yikes&quot;&gt;呀&lt;/a&gt;，比较一下这个仓库&lt;a href=&quot;https://github.com/spring-projects/spring-framework/commits/5ba3db?author=philwebb&quot;&gt;最近的提交&lt;/a&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git log --oneline -5 --author pwebb --before &amp;quot;Sat Aug 30 2014&amp;quot;

5ba3db6 Fix failing CompositePropertySourceTests
84564a0 Rework @PropertySource early parsing logic
e142fd1 Add tests for ImportSelector meta-data
887815f Update docbook dependency and generate epub
ac8326d Polish mockito usage
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你更喜欢读哪个呢？&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>[译]C 程序的原则</title>
    <link href="https://jiongks.name//blog/principles-for-c-programming/"/>
    <id>https://jiongks.name//blog/principles-for-c-programming/</id>
    <published>2017-03-19T04:48:07.000Z</published>
    <updated>2017-03-19T05:07:11.000Z</updated>
    
    <content type="html"><![CDATA[<p><mark>译自：<a href="https://drewdevault.com/2017/03/15/How-I-learned-to-stop-worrying-and-love-C.html">Principles for C programming</a></mark></p><p>按照 Doug Gwyn 的话说：“Unix 不会阻止你做愚蠢的事情，因为那会同样阻止你做聪明的事情”。C 是一个非常强大的工具，但使用它的时候需要非常小心和<a href="http://dict.cn/discipline">自律</a>。学习这些纪律是绝对值得的，因为 C 是所有程序语言中最优秀的。一个自律的 C 程序员将会……</p><p><strong>喜欢可维护性</strong>。不要在不必要的地方自作聪明。取而代之的是，找出最简单最易懂的满足需求的方案。诸如性能之类考量是放在第二位的。你应该为你的代码做一个性能预算，并自在的支配它。</p><p>随着你对这门语言越来越<a href="http://dict.cn/proficient">了解</a>，掌握了越来越多能够从中获益的特性，你也应该学会什么时候不能使用它们。相比用到了很多新奇的方式去解决问题，易于<a href="http://dict.cn/novice">新手</a>理解是更重要的。最好是让一个新手理解你的代码并从中有所收获。像你<a href="http://dict.cn/circa">大概</a>去年就在维护它一样去撰写代码。</p><p><strong>避免使用魔法</strong>。不要使用宏 (macros)——尽管用它定义常量是没问题的。不要使用 typedef 来隐藏指针或回避撰写“结构”。避免撰写复杂的抽象。保持你的构建系统简单透明。不要因为一个愚蠢的 hacky 的<a href="http://dict.cn/crap">废物</a>解决问题的方式酷炫就使用它。你的代码在行为<a href="http://dict.cn/underlying">之下</a>应该是明显的，甚至不需要上下文。</p><p>C 最大的优势之一就是透明和简单。这应该被信奉，而不是被<a href="http://dict.cn/subverted">颠覆</a>。但是 C 的优良传统是给你足够的空间施展自己，所以你可以为了一些魔术般的目的使用它。但最好还是不要这样，做个<a href="http://dict.cn/muggle">麻瓜</a>挺好的。</p><p><strong>辨识并回避危险的模式</strong>。不要使用固定尺寸的 buffers (有人指出这种说法并不是完全正确。我之前打草稿的时候提到了这些，但还是删掉了)——始终计算你需要分配的空间。阅读你使用的函数的 man 手册并掌握他的成功有出错模式。立刻把不安全的用户输入转换为<a href="http://dict.cn/sanitized">干净</a>的 C 结构。如果你之后会把这些数据展现给用户，那么尽可能把 C 结构保持到最后。要学会在使用例如 strcat 的敏感函数时多加留意。</p><p>撰写 C 有的时候像握着一把枪。枪是很重要的工具，但是和枪有关的事故都是非常糟糕的。你对待枪要非常小心：不要用枪指着任何你喜爱的东西，要有好的用枪<a href="http://dict.cn/discipline">纪律</a>，把它当作始终上膛一样谨慎。而就像枪善于拿来打孔一样，C 也善于用来撰写内核。</p><p><strong>用心组织代码。</strong>永远不要把代码写到 header 里。永远不要使用 <code>inline</code> 关键字。把独立的东西分开写成不同的文件。<a href="http://dict.cn/liberally">大量</a>使用静态方法组织你的逻辑。用一套编码规范让一切都有足够的<a href="http://dict.cn/breathing%20room">空间</a>且易于阅读。当目的<a href="http://dict.cn/self-evident">显而易见</a>的情况下使用单字符变量名，反之则使用<a href="http://dict.cn/descriptive">描述性</a>的变量名。</p><p>我喜欢把我的代码组织成目录，每个目录实现一组函数，每个函数有属于自己的文件。这些文件通常会包含很多静态函数，但是它们全部用于组织这个文件所要实现的行为。写一个 header 允许这个模块被外部访问。并使用 Linux 内核编码规范，<a href="http://dict.cn/god%20dammit">该死</a>。</p><p><strong>只使用标准的特性</strong>。不要把平台假设为 Linux。不要把编译器假设为 gcc。不要把 libc 假设为 glibc。不要把架构假设为 x86 的。不要把核心工具假设为 GNU。不要定义 <code>_GNU_SOURCE</code>。</p><p>如果你一定要使用平台相关的特性，为这样的特性描述一个接口，然后撰写各自平台相关的支持代码。在任何<a href="http://dict.cn/circumstances">情况</a>下都不要使用 gcc 扩展或 glibc 扩展。GNU 是<a href="http://dict.cn/blight">枯萎的</a>，不要让它<a href="http://dict.cn/infect">传染</a>到你的代码。</p><p><strong>使用<a href="http://dict.cn/discipline">严谨</a>的工作流</strong>。也要有严谨的版本控制方法。撰写提交记录的时候要<a href="http://dict.cn/thoughtful">用心</a>——在第一行简短解释变动，然后在扩展提交记录中加上改变它的<a href="http://dict.cn/justification">理由</a>。在 feature 分支上工作要明确定义目标，不要包含和这个目标不相关的改动。不要害怕在 rebase 时编辑你的分支的历史，它会让你的改动展示得更清晰。</p><p>当你稍后不得不回退你的代码时，你将会感激你之前详尽撰写的提交记录。其他人和你的代码互动时也同样会心存感激。当你看到一些愚蠢的代码时，也可以知道这个<a href="http://dict.cn/bastard">白痴</a>当时是怎么想的，尤其是当这个<a href="http://dict.cn/bastard">白痴</a>是你自己的时候。</p><p><strong>严格测试和<a href="http://dict.cn/review">回顾</a></strong>。找出你的改动可能会经过的代码路径。测试每条路径的行为是正确的。给它不正确的输入。给它“永远不可能发生”的输入。对<a href="http://dict.cn/error-prone">有错误倾向</a>的模式格外小心。寻找可以简化代码的地方并让过程变得更清晰。</p><p>接下来，把你的改动交给另外一个人进行<a href="http://dict.cn/review">回顾</a>。这个人应该运用相同的程序并签署你的改动。而且<a href="http://dict.cn/review">回顾</a>要<a href="http://dict.cn/discipline">严格</a>，标准始终如一。<a href="http://dict.cn/review">回顾</a>的时候应该想着，如果由于这些代码出了问题，自己会<a href="http://dict.cn/be%20your%20ass%20on%20the%20line">感到耻辱</a>。</p><p><strong>从错误中学习</strong>。首先，修复 bug。然后，修复实际的 bug：你的流程允许里这个错误的发生。拉<a href="http://dict.cn/review">回顾</a>你代码的人讨论——这是你们共同的过错。严格的检查撰写、<a href="http://dict.cn/review">回顾</a>和部署这些代码的流程，找出<a href="http://dict.cn/root%20cause">根源</a>所在。</p><p>解决方案可以简单，比如把 strcat 加入到你的触发“认真回顾”<a href="http://dict.cn/reflex">条件反射</a>的函数列表。它可以通过电脑进行静态分析，帮你检测到这个问题。可能这些代码需要<a href="http://dict.cn/refactored">重构</a>，这样找出问题变得简单容易。疏于避免未来的<a href="http://dict.cn/fuck-up">错误</a>才是真的<a href="http://dict.cn/fuck-up">大错</a>。</p><hr><p>重要的是记住规则就是用来打破的。可能有些情况下，不被鼓励的行为是有用的，被鼓励的行为是应该<a href="http://dict.cn/disregarded">被忽视的</a>。你应该<a href="http://dict.cn/strive">力争</a>把这些情况当作例外而不是<a href="http://dict.cn/norm">常态</a>，并当它们发生时仔细的<a href="http://dict.cn/justify">证明</a>它们。</p><p>C 是狗屎。我爱它，并希望更多的人可以学到我做事的方式。祝好运！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;mark&gt;译自：&lt;a href=&quot;https://drewdevault.com/2017/03/15/How-I-learned-to-stop-worrying-and-love-C.html&quot;&gt;Principles for C programming&lt;/a&gt;&lt;/ma
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Vue 2.0 来了！</title>
    <link href="https://jiongks.name//blog/vue-2-is-here/"/>
    <id>https://jiongks.name//blog/vue-2-is-here/</id>
    <published>2016-10-01T12:45:09.000Z</published>
    <updated>2017-08-01T03:00:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>终于发布了！</p><p>原文：<a href="https://medium.com/the-vue-point/vue-2-0-is-here-ef1f26acf4b8#.6r9xjmu6x">https://medium.com/the-vue-point/vue-2-0-is-here-ef1f26acf4b8#.6r9xjmu6x</a></p><p>今天我非常兴奋的官宣 Vue.js 2.0 的发布：Ghost in the Shell。历经 8 个 alpha 版本、8 个 beta 版本和 8 个 rc 版本 (矮油好巧！)，Vue.js 2.0 已经为生产环境准备好了！我们的官方教程 <a href="https://vuejs.org/guide/">vuejs.org/guide</a> 也已经全面更新。</p><p>2.0 的工作自今年 4 月启动以来，<a href="https://github.com/orgs/vuejs/people">核心团队</a>为 API 设计、bugfix、文档、类型声明做出了很重要的贡献，社区中的同学们也反馈了很多有价值的 API 建议——在此为每一位参与者致以大大的感谢！</p><a id="more"></a><h3 id="2-0-有哪些新东西"><a href="#2-0-有哪些新东西" class="headerlink" title="2.0 有哪些新东西"></a>2.0 有哪些新东西</h3><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p><img src="https://d262ilb51hltx0.cloudfront.net/max/1600/1*Lu6OJiraJYShl4aBppoh3w.png" alt="基于第三方 benchmark，数值越低越好"></p><p>基于<a href="http://stefankrause.net/js-frameworks-benchmark4/webdriver-ts/table.html">第三方 benchmark</a>，数值越低越好</p><p>2.0 用一个 fork 自 <a href="https://github.com/snabbdom/snabbdom">snabbdom</a> 的轻量 Virtual DOM 实现对渲染层进行了重写。在其上层，Vue 的模板编译器能够在编译时做一些智能的优化处理，例如分析并提炼出静态子树以避免界面重绘时不必要的比对。新的渲染层较之 v1 带来了巨大的性能提升，也让 Vue 2.0 成为了最快速的框架之一。除此之外，它把你在优化方面需要做的努力降到了最低，因为 Vue 的响应系统能够在巨大而且复杂的组件树中精准的判断其中需要被重绘的那部分。</p><p><img src="https://d262ilb51hltx0.cloudfront.net/max/1600/1*xV2_bx4eWC9RXiBZjeAMrw.png" alt=""></p><p>还有个值得一提的地方，就是 2.0 的 runtime-only 包大小 min+gzip 过后只有 16kb，即便把 <em>vue-router</em> 和 <em>vuex</em> 都包含进去也只有 26kb，和 v1 核心的包大小相当！</p><h4 id="渲染函数"><a href="#渲染函数" class="headerlink" title="渲染函数"></a>渲染函数</h4><p>尽管渲染层全面更新，Vue 2.0 兼容了绝大部分的 1.0 模板语法，仅废弃掉了其中的一小部分。这些模板在背后被编译成了 Virtual DOM 渲染函数，但是如果用户需要更复杂的 JavaScript，也可以选择在其中直接撰写渲染函数。同时我们为喜欢 JSX 的同学提供了<a href="https://github.com/vuejs/babel-plugin-transform-vue-jsx">支持选项</a></p><p>渲染函数使得这种基于组件的开发模式变得异常强大，并打开了各种可能性——比如现在新的 transition 系统就是完全基于组件的，内部由渲染函数实现。</p><h4 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h4><p>Vue 2.0 支持服务端渲染 (SSR)，并且是<a href="https://github.com/vuejs/vue/tree/dev/packages/vue-server-renderer#rendererrendertostreamvm">流式的</a>，可以做<a href="https://github.com/vuejs/vue/tree/dev/packages/vue-server-renderer#component-caching">组件级的缓存</a>，这使得极速渲染成为可能。同时，<em>vue-router</em> 和 <em>vuex</em> 2.0 也都支持了可以通用路由和客户端状态“hydration”的服务端渲染。你可以通过 <a href="https://github.com/vuejs/vue-hackernews-2.0/">vue-hackernews-2.0 的 demo app</a> 了解到它们是如何协同工作的。</p><h3 id="辅助库"><a href="#辅助库" class="headerlink" title="辅助库"></a>辅助库</h3><p>官方支持的库和工具——<em>vue-router</em>、<em>vuex</em>、<em>vue-loader</em> 和 <em>vueify</em>——都已经升级并支持 2.0 了。<strong>vue-cli 现在已经默认生成 2.0 的脚手架了。</strong></p><p>特别之处在于，<em>vue-router</em> 和 <em>vuex</em> 在它们的 2.0 版本中都已经有了很多改进：</p><p><strong>vue-router</strong></p><ul><li>支持多命名的 <code>&lt;router-view&gt;</code></li><li>通过 <code>&lt;router-link&gt;</code> 组件改进了导航功能</li><li>简化了导航的 hooks API</li><li>可定制的滚动行为控制</li><li><a href="https://github.com/vuejs/vue-router/tree/dev/examples">更多复杂示例</a></li></ul><p><strong>vuex</strong></p><ul><li>简化了组件内的用法</li><li>通过改进 modules API 提供更好的代码组织方式</li><li>可聚合的异步 actions</li></ul><p>它们各自的 2.0 文档里有更多的细节：</p><ul><li><a href="https://router.vuejs.org/">https://router.vuejs.org/</a></li><li><a href="https://vuex.vuejs.org/">https://vuex.vuejs.org/</a></li></ul><h4 id="社区项目"><a href="#社区项目" class="headerlink" title="社区项目"></a>社区项目</h4><p>中国最大的在线订餐平台饿了么的<a href="https://github.com/ElemeFE/">团队</a>已经基于 Vue 2.0 构建了<a href="https://github.com/ElemeFE/element">一套完整的桌面 UI 组件库</a>。不过还没有英文文档，但是他们正在为此而努力！</p><p>很多其他社区的项目也都在为 2.0 做兼容——请移步到 <a href="https://github.com/vuejs/awesome-vue">awesome-vue</a> 搜索关键字“2.0”。</p><h3 id="从-1-0-迁移"><a href="#从-1-0-迁移" class="headerlink" title="从 1.0 迁移"></a>从 1.0 迁移</h3><p>如果你是一个 Vue 的新同学，现在就可以“无脑”使用 Vue 2.0 了。最大的问题其实是目前 1.0 的用户如何迁移到新的版本。</p><p><img src="https://d262ilb51hltx0.cloudfront.net/max/1600/1*157Ly5X6gx0C2CIvsMaNog.png" alt=""></p><p>为了帮助大家完成迁移，团队已经在配合 <a href="https://github.com/vuejs/vue-migration-helper">CLI 迁移辅助工具</a>制作<a href="https://vuejs.org/guide/migration.html">非常详实的迁移教程</a>。这个工具不一定捕获每一处被废弃的东西，但相信能帮你开个好头。</p><h3 id="One-More-Thing……"><a href="#One-More-Thing……" class="headerlink" title="One More Thing……"></a>One More Thing……</h3><p>中国最大的电商公司阿里巴巴的工程师们已经发起了一个叫做 <a href="https://github.com/alibaba/weex">Weex</a> 的项目，通过 Vue-inspired 语法在移动端渲染 native UI 组件。但是很快，“Vue-inspired” 将会成为 “Vue-powered”——我们已经启动了官方合作，让 Vue 2.0 真正成为 Weex 的 JavaScript 运行时框架。这让用户能够撰写横跨 Web、iOS 和 Android 的通用 Vue 组件！我们的合作才刚刚开始，这将会是 2.0 发布后未来我们专注的重点，请大家拭目以待！</p><p>Vue 从一个不起眼的 side project 开始如今已经有了长足的发展。今天它已经是<a href="https://www.patreon.com/evanyou">社区资助的</a>，<a href="https://www.quora.com/How-popular-is-VueJS-in-the-industry/answer/Evan-You-3?__snid3__=365957938&amp;__nsrc__=2&amp;__filter__">被实际广泛认可的</a>，并且根据 <a href="http://stats.js.org/">stats.js.org</a> 统计在所有 JavaScript 库中增势最强劲的一个。我们相信 2.0 会走得更远。这是 Vue 自启动以来最大的一次更新，我们期待大家用 Vue 创造出更多好产品！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;终于发布了！&lt;/p&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://medium.com/the-vue-point/vue-2-0-is-here-ef1f26acf4b8#.6r9xjmu6x&quot;&gt;https://medium.com/the-vue-point/vue-2-0-is-here-ef1f26acf4b8#.6r9xjmu6x&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;今天我非常兴奋的官宣 Vue.js 2.0 的发布：Ghost in the Shell。历经 8 个 alpha 版本、8 个 beta 版本和 8 个 rc 版本 (矮油好巧！)，Vue.js 2.0 已经为生产环境准备好了！我们的官方教程 &lt;a href=&quot;https://vuejs.org/guide/&quot;&gt;vuejs.org/guide&lt;/a&gt; 也已经全面更新。&lt;/p&gt;
&lt;p&gt;2.0 的工作自今年 4 月启动以来，&lt;a href=&quot;https://github.com/orgs/vuejs/people&quot;&gt;核心团队&lt;/a&gt;为 API 设计、bugfix、文档、类型声明做出了很重要的贡献，社区中的同学们也反馈了很多有价值的 API 建议——在此为每一位参与者致以大大的感谢！&lt;/p&gt;
    
    </summary>
    
    
      <category term="vue" scheme="https://jiongks.name/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Weex 近 4 个月的开源之路</title>
    <link href="https://jiongks.name//blog/weex-open-source-4-months/"/>
    <id>https://jiongks.name//blog/weex-open-source-4-months/</id>
    <published>2016-09-04T22:21:00.000Z</published>
    <updated>2016-09-04T22:21:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><mark>本文早些时候发表在 weexteam 的博客 <a href="https://github.com/weexteam/article/issues/73">https://github.com/weexteam/article/issues/73</a></mark></p><p>仅从我个人角度跟大家分享一下自己参与 Weex 开源这几个月以来的感受，中间可能会有写观点是偏颇的或者片面的，希望大家指正，另外不论怎样，这些都是我心里真实的想法和感受。</p><p><a href="https://camo.githubusercontent.com/d0c177d907349f637ff7128ff4cf3ca51ec892da/687474703a2f2f696d67312e746263646e2e636e2f4c312f3436312f312f63643261353863303665336637363332386239623930666432383932623233386631646665326466"><img src="https://camo.githubusercontent.com/d0c177d907349f637ff7128ff4cf3ca51ec892da/687474703a2f2f696d67312e746263646e2e636e2f4c312f3436312f312f63643261353863303665336637363332386239623930666432383932623233386631646665326466" alt="image"></a></p><h3 id="为什么选择开源"><a href="#为什么选择开源" class="headerlink" title="为什么选择开源"></a>为什么选择开源</h3><p>有两个关键字：加速、共赢</p><p>我们提出来要开源的时候，在网上被很多人质疑过。有人质疑说这是个“KPI项目”，作者折腾完要“弃坑”了，所以就把它开源了；也有人质疑它的成色，也有人质疑“电商”的标签，是不是只有你们阿里用得到，别人都不太用得到。</p><p>我觉得开源最大的意义在于找到志同道合的人做出更伟大的事情，如果我们只是为了“弃坑”，那显然在4个月之前我们的工作就完成了，也不会有接下来的研发迭代、宣传、开发者服务和社区经营——最起码我自己从 Weex 还没有开源甚至还没有这个名字的时候就参与其中，一直参与到现在。我喜欢这个项目，也愿意接受这个项目带给我的各种刺激和挑战，他一直让我不断进步，有满满的收获。</p><p>话说回来，我确实看到很多社区的开源项目，自己厂的、友商的、个人的，确实有“弃坑”的意味，感觉源代码丢到 github 就没事了。我觉得这种开源不是没有价值，但价值是约等于 0 的。这段时间关注奥运会，也一下子想起奥林匹克之父顾拜旦老人家的一句名言：“生活的本质不在于索取，而在于奋斗！”我觉得这句话在开源社区更是如此。把代码开源出去然后撒手不管等着别人来捡，这实际上是索取，是没有意义的。关注开源项目的开发者表面上是索取，但是开发者提交的每一个 pull request、每一条 issue、甚至每一句评论和吐槽，也是在为项目做贡献。作为开源项目的参与者或作者，一定要在这方面有一个健康的心态，才能真正做出好的项目。</p><p>我还记得自己 2010 年参加 WebRebuild 交流会的时候，<a href="http://www.slideshare.net/josephj/webrebuild">蒋定宇 的分享</a> 让我印象深刻，他其中一句话我到今天还记得：</p><blockquote><p>“最好的 solution 是讨论出来的”</p></blockquote><p>所以如果想做出优秀的开源项目，除了摆正自己的心态，还要有一颗和别人 (甚至竞争对手和讨厌你的人) 一起共赢的心。尽可能团结一切可以团结的力量。让这个项目变得更好！</p><h3 id="筹备过程：从心态到模式的全面转变"><a href="#筹备过程：从心态到模式的全面转变" class="headerlink" title="筹备过程：从心态到模式的全面转变"></a>筹备过程：从心态到模式的全面转变</h3><p>团队内部从去年双十一之后宣布开源计划，到从4月份 QCon 开始邀请开发者陆续参与进来，再到6月底正式全面开源，一共经历了大概了大半年的时间。团队是把 Weex 开源这件事情当做一个工程来认真对待的，这里可以跟大家分享一些我们背后做的准备工作：</p><h4 id="例行公事：脱敏、回避公司账号"><a href="#例行公事：脱敏、回避公司账号" class="headerlink" title="例行公事：脱敏、回避公司账号"></a>例行公事：脱敏、回避公司账号</h4><p>这是集团很早就定下来的规矩，我理解这件事情更大程度上是“怕出事”，不要不小心把不该公开的信息公开出去导致集团不必要的商业损失。我觉得这理所当然，同时这只是个最低要求。</p><p>当然集团今天对待开源已经不是“怕出事”这么简单了，我自己能够感觉到，集团新成立的开源委员会，除了通过这个流程帮助开发者打消不必要的顾虑之外，更多的希望我们能够通过开源的方式让一件事加速和共赢。这是我参与 Weex 开源过程中明显感受到和之前不一样的地方。</p><h4 id="开放的工作环境和工作流程：issues、异步沟通的习惯、熟悉远程沟通的模式"><a href="#开放的工作环境和工作流程：issues、异步沟通的习惯、熟悉远程沟通的模式" class="headerlink" title="开放的工作环境和工作流程：issues、异步沟通的习惯、熟悉远程沟通的模式"></a>开放的工作环境和工作流程：issues、异步沟通的习惯、熟悉远程沟通的模式</h4><p>除了上面的“硬性”准备工作之外，对 Weex 团队更大的挑战在于工作方式的转变。在阿里有句土话，“能电话不邮件”，讲求的是密切沟通、快速响应，阿里的很多团队也是因此具有其他团队不曾想象的做事决心和执行力。在开源社区，面对海量的开发者一起参与，还要做好开发者服务，这种工作方式是不合适的。我们需要大量依赖线上的、异步的、远程的、开放的工作模式。</p><p>在团队内部，我们有意识的把所有的工作讨论和任务安排，能公开出来的，就全部公开在 github issue 里。随着团队成员的增多，我们的团队有杭州、北京、广州的，大家分散办公，然后在线上沟通，把不需要当面或同步沟通的工作大方的区分出来。表面上看，异步沟通增加了团队的沟通成本，但实际上，异步沟通让能够参与进来的人变多了，而且不仅限于杭州的某一个办公区或会议室的人，彼此也可以更自在灵活的安排自己的工作和行程。这给了项目组很多想象和发挥的空间。</p><p><a href="https://camo.githubusercontent.com/9e1cf594b80c7fd28077c85fee4d8d68715d9b7a/687474703a2f2f696d67342e746263646e2e636e2f4c312f3436312f312f37616433356434303934613538633062376236306533613862643939303166373761343562323037"><img src="https://camo.githubusercontent.com/9e1cf594b80c7fd28077c85fee4d8d68715d9b7a/687474703a2f2f696d67342e746263646e2e636e2f4c312f3436312f312f37616433356434303934613538633062376236306533613862643939303166373761343562323037" alt="image"></a></p><p>甚至不只是 Weex 这个项目，我希望集团层面都可以更多的尝试远程协作和异步沟通，这是一种有魔力的体验。</p><h4 id="培养兴趣和认同感，把开源当做马拉松，分配好体能，不能一蹴而就"><a href="#培养兴趣和认同感，把开源当做马拉松，分配好体能，不能一蹴而就" class="headerlink" title="培养兴趣和认同感，把开源当做马拉松，分配好体能，不能一蹴而就"></a>培养兴趣和认同感，把开源当做马拉松，分配好体能，不能一蹴而就</h4><p>在筹备期间，我有幸和集团的几位开源的前辈聊到过我们的开源设想，印象最深刻的一个问题就是：</p><blockquote><p>“你是否确定，如果有一天你的 KPI 里没有这个项目了，甚至你有一天不在阿里工作了，你会发自内心的去投入和维护它吗？”</p></blockquote><p>我听完觉得前辈把话说到我们心坎儿里了。项目组核心团队里的每一个人，是把 Weex 简单当一份工作，还是发自内心的认同，做出来的东西我相信是完全不一样的。你会全职参与到一个项目里，还是兼职，有的时候兼职的效果更好，更健康。尤其是当我们从长计议的时候，对这几方面更加有感触。我们有大量的已经开源的项目，更新频度是大于半年的。这样的项目出发点都是很好的，但是结果很可惜。</p><p>我们在后期组建团队让更多人参与进来的时候特别思考了这个问题，今天在集团内部，Weex 的很多东西都是业务的同学在帮忙打理的。从项目组的角度，工作压力得到了分担和缓解；从个人的角度，在支持业务的同时，能够把一些比较解耦的工作拿来业余时间独自承担，松散的参与一些技术讨论，有自己的收获。这是两全其美的事情。</p><p>另外团队的既定工作安排是非饱和的，我们鼓励团员主动寻找值得参与和付出的地方，把项目的方方面面打理好，毕竟项目是完全对外的嘛，要“出去见人”总得把自己“打扮的漂漂亮亮的”。这是每个人都会有的心态。坦白讲这方面我们还不算做得特别好。所以有很多工作要继续做，也有很多空间给到团队。</p><h4 id="欢迎把分散的工作内容到不同的团队和个人"><a href="#欢迎把分散的工作内容到不同的团队和个人" class="headerlink" title="欢迎把分散的工作内容到不同的团队和个人"></a>欢迎把分散的工作内容到不同的团队和个人</h4><p>我们主动联系了很多和 Weex 有共同志向或相关联的团队和事业部，大家在不同的角度能够看到更多不同层次的问题，也有各自擅长的领域和空间。我们希望在 Weex 项目组之外，把一个围绕着 Weex 的生态建立起来，他会让 Weex 变得更丰富饱满，更有意义，更有价值。</p><p>今天在阿里，Weex 杭州的团队已经只是参与 Weex 的所有人中一小部分了，不同的业务方，不同的技术层次上，都有不同的小伙伴在参与。</p><p><a href="https://camo.githubusercontent.com/d70e804ab573c38736dd62cbf5c1a6b0531ce78d/687474703a2f2f696d67332e746263646e2e636e2f4c312f3436312f312f38333536393464356539613230303030376462643933303166663031383262333362353539303863"><img src="https://camo.githubusercontent.com/d70e804ab573c38736dd62cbf5c1a6b0531ce78d/687474703a2f2f696d67332e746263646e2e636e2f4c312f3436312f312f38333536393464356539613230303030376462643933303166663031383262333362353539303863" alt="image"></a></p><h4 id="团队选择-6-30-正式开源"><a href="#团队选择-6-30-正式开源" class="headerlink" title="团队选择 6-30 正式开源"></a>团队选择 6-30 正式开源</h4><p>经过两个多月的筹备，我们于6月30日晚把项目正式开源了，我们在微博上做了个<a href="http://weibo.com/5897827106/DCFtruTbc">简单的宣传</a>，但实际上团队当时内部压力是蛮大的，大家都很辛苦，所以我们搞了个小的 party，煞有介事的搬来一个“重大决策按钮”，很有仪式感的让大家一起把这个按钮按下去，把项目开源出来，尽量把这个过程搞得轻松愉悦一点。</p><p>开源之前大概就是这样，团队紧接着要面对的，是开源之后的漫长之路。</p><h3 id="开源之后：更好的服务开发者"><a href="#开源之后：更好的服务开发者" class="headerlink" title="开源之后：更好的服务开发者"></a>开源之后：更好的服务开发者</h3><p>我总结的开源社区经营就是一个“帽子戏法”的过程，就像开淘宝店是一样的，有三顶帽子你需要轮流得把他带到自己头上：</p><p>如果你要开店，那么你首先需要备货，拥有用户满意的商品；然后找入口买流量，让别人看到你的商品；用户发现你的商品之后，你要有很好的承接和售后服务；等到商品卖出去了，用户肯定会给你沟通、评价和建议，这会作为你拥有更好商品的筹码。每个环节之间都是紧密联系的，哪个做得不够平衡都会很痛苦。</p><p><a href="https://camo.githubusercontent.com/c82a13386a0388932fdfd918d3477e00829ee370/687474703a2f2f696d67322e746263646e2e636e2f4c312f3436312f312f35373434396133323338313262643239306261303564646638343534393231623136306565376336"><img src="https://camo.githubusercontent.com/c82a13386a0388932fdfd918d3477e00829ee370/687474703a2f2f696d67322e746263646e2e636e2f4c312f3436312f312f35373434396133323338313262643239306261303564646638343534393231623136306565376336" alt="image"></a></p><p>做开源项目也是一样，首先你要做出好的技术产品；然后通过各种技术宣讲机会介绍给别人；当开发者来到项目的首页或 github 仓库时，要做好服务，帮助开发者解答参与过程中的疑惑；然后在这个过程中收集到用户的反馈和意见再做产品的迭代改进。</p><p><a href="https://camo.githubusercontent.com/3fdfcb3e7eb0c1c5553e08859eda5a61bb83f633/687474703a2f2f696d67312e746263646e2e636e2f4c312f3436312f312f33366335306634326533306230363665653334636638633466633733663966646233616261636362"><img src="https://camo.githubusercontent.com/3fdfcb3e7eb0c1c5553e08859eda5a61bb83f633/687474703a2f2f696d67312e746263646e2e636e2f4c312f3436312f312f33366335306634326533306230363665653334636638633466633733663966646233616261636362" alt="image"></a></p><h4 id="利用-QCon-等机会推广宣传"><a href="#利用-QCon-等机会推广宣传" class="headerlink" title="利用 QCon 等机会推广宣传"></a>利用 QCon 等机会推广宣传</h4><p>包括4月份我们参与的 QCon 北京在内，团队先后参加了大大小小的很多场技术交流分享活动，同时在线上我们也在陆续写一些介绍 Weex 的技术文章，在宣传 Weex 的技术设想和理念的同时，也鼓励开发者更多的参与进来。</p><h4 id="解答问题时遇到的问题"><a href="#解答问题时遇到的问题" class="headerlink" title="解答问题时遇到的问题"></a>解答问题时遇到的问题</h4><p>现在回想起来，最早接触开发者的时候，团队对自己还是太过自信了，心想我们一起研发并且准备了这么久，开发者过来看过一定觉得很厉害。没想到遇到了大家的各种挑战。而且被问到最多的问题是完全没有想到的：</p><blockquote><p>“怎么让程序跑起来？”</p></blockquote><p>然后就发现了一堆问题：比如 Windows 环境下的命令行问题、路径分隔符问题、Node 版本问题、Android 环境翻墙的问题、npm/cocoapods 镜像的问题、NDK 的问题、x86 模拟器的问题等等……</p><p>这里面有些是团队自己知道的，只是觉得太顺理成章了，没觉得应该写清楚，结果就让开发者们误解了；有些确实是自己的工作环境很单一，而社区里开发者们的工作环境是千差万别的；还有些是交代得不够清楚，明明知道也写了，但是没能让开发者很好的充分理解。</p><p>后来我才留意到技术社区里一个流传很久的笑话：</p><blockquote><p>“所有的开源软件都有一个特点：根据官方文档的步骤是跑不起来的。”</p></blockquote><p>原来 Landing Page、README 和 文档这么重要，这给了团队当头一棒，大家认为最简单的问题都折腾得很狼狈。看起来搞开源真的“不是你一片赤诚就能够面对的”</p><h4 id="经历了从-issue-邮件爆仓到-QQ-群再到-gitter-的过程"><a href="#经历了从-issue-邮件爆仓到-QQ-群再到-gitter-的过程" class="headerlink" title="经历了从 issue 邮件爆仓到 QQ 群再到 gitter 的过程"></a>经历了从 issue 邮件爆仓到 QQ 群再到 gitter 的过程</h4><p>最早期我们和开发者所有的沟通基本都是通过 github issues 来进行的，这也蛮正常的，看人家开源项目都在 issues 上讨论的火热，好有气氛好羡慕，巴不得有人在我们自己的 issues 上多聊个两句，哪怕是闲聊，总比冷冷清清无人问津的好。</p><p>后来发现完全不是我们想象的那样，我们真的是想多了，实际情况是各种 issue 洪水猛兽版袭来，大家的 github 账号默认都是可以收到每个 issue 的邮件提醒的，然后瞬间邮箱就被炸瘫痪了，正常的研发迭代也被应付这些 issue 变得支离破碎。</p><p>后来我们发现其实 issue 其实并不都适合处理所有的问题，有些使用上的小问题，在 issue 上几个来回讨论清楚，一个小时甚至一上午就这样过去了。而且问题多了之后，把 issues 上正常的工作内容讨论和安排都给淹没了。</p><p>这个时候就有非常热心的开发者帮我们建立了 QQ 群、微信群等社区，这种沟通方式更直接简单，回合更快，开发者遇到一个编译不通过的问题，问题抛出来在线等个几分钟就有人帮忙回应了。这样 github issues 的压力暂时得到了缓解。</p><p>后来经过几个同学的调研，我们最终把疑难杂症的解答和及时的线上讨论放到了 gitter 上，把需要跟进的事项、发现的 bug、值得追踪探讨的话题留在了 github issues 里。这样差不多是今天团队和社区开发者们协作的最终方式了。</p><h4 id="根据开发者参与程度分场景提供不一样的支持"><a href="#根据开发者参与程度分场景提供不一样的支持" class="headerlink" title="根据开发者参与程度分场景提供不一样的支持"></a>根据开发者参与程度分场景提供不一样的支持</h4><p>我们根据开发者的参与度划分了几个维度：随便看看、试一试、用起来、交流互动、参与贡献。背后的需求和服务方式应该是不一样的</p><ul><li>如果开发者只是想先来了解个概念，我们要做的就是做个漂漂亮亮的欢迎页、还有 README，把主要功能、特点和适用范围交代清楚</li><li>如果开发者看过之后觉得有兴趣尝试一下，我们要准备的是入门教程、预览工具、代码示例和 cli 入口集成工具</li><li>如果开发者尝试过之后觉得不错，准备在实际工作中使用 Weex，那么我们要提供的东西就更复杂，包括详实的参考文档、丰富的工程示例、必备的所有工程工具集、还有常见问题的整理等等，更重要的是，要有稳定的版本。</li><li>如果开发者自己用过之后，还乐于和众多其他 Weex 的开发者交流互动，我们要提供的就是 github、gitter 这样的平台，方便大家一起管理事物、及时解答和探讨各种问题，必要的情况下，我们会主动和我们的用户建立联系，了解更多大家平时不一定愿意主动说出来的观点和细节。</li><li>最后，对于有能力和意愿为 Weex 做出更大贡献的开发者，我们需要提供更完整和演进的开发规范、技术约定和质量保障机制，让大家更低成本的参与贡献，同时还可以保障基本的代码质量和工程质量。</li></ul><h4 id="文章和讨论逐步沉淀"><a href="#文章和讨论逐步沉淀" class="headerlink" title="文章和讨论逐步沉淀"></a>文章和讨论逐步沉淀</h4><p>随着 Weex 社区参与者的增多，我们也不需要鼓励大家有事没事写个 issue 打肿脸充胖子了，而是比较自然而合理的做各种事情。我们看到两个很好的势头：</p><p>一个是开发者在 issues 里参与了很多基于 proposal 的新功能讨论，之前团队在迭代新功能的时候是自行设计排期研发实现的，逐渐的，我们把整个技术设计的过程也透明出来并且有意识的在这个阶段放慢节奏，让这个功能经过足够充分的讨论之后，再付诸实现；</p><p>另一个是很多开发者开始在集团内网和 github articles 下写了越来越多对 Weex 的理解和相关讨论，很多文章团队自己看完都私下表示开发者们写得比我自己写得都好 [偷笑]，这也让团队的每一个人更受鼓舞，也更愿意跟社区分享自己的想法和真知灼见。</p><p>这两方面不论哪一方面，对 Weex 社区来说都是很好的迹象，也都一定程度鼓舞了 Weex 团队本身做得更好！</p><h4 id="有秩序分版本迭代和-release，因为有了上述的影响，最近的迭代也加快了节奏"><a href="#有秩序分版本迭代和-release，因为有了上述的影响，最近的迭代也加快了节奏" class="headerlink" title="有秩序分版本迭代和 release，因为有了上述的影响，最近的迭代也加快了节奏"></a>有秩序分版本迭代和 release，因为有了上述的影响，最近的迭代也加快了节奏</h4><p>就像开源之后第一段提到的，Weex 团队除了宣传和服务开发者之外，还在保持有条不紊的版本迭代。去年 Weex 初期启动的时候，是一个7人左右的团队，通过不那么标准的 Scrum 的敏捷方式快速迭代。双十一过后，团队的规模扩大了，同时也有了非常专业的项目经理为团队保驾护航。我们基本保持着每个月一次迭代，每两个迭代发布一个版本的节奏，所以我们于5月份发布了0.5版本，7月份发布了0.6版本。</p><p>从0.7版本开始，随着团队默契度的提升，再加上整个社区逐步成型，也通过 proposal 讨论等机会给了团队很多回馈，我们加快了迭代频率，现在每个月都会完成一个新的版本，所以本月初我们发布了0.7版本。目前0.8版本也已经启动，正在紧锣密鼓的迭代过程中。</p><p>同时今年的双十一也要邻近了，团队针对今年双十一提出了更高的目标，具体内容这里不详细提及了，先卖个关子，请大家拭目以待。</p><h3 id="未来的努力方向"><a href="#未来的努力方向" class="headerlink" title="未来的努力方向"></a>未来的努力方向</h3><p>今天，Weex 在近4个月的开源之路后，累计了5000+个star，并且保持着比较高的迭代速度和社区活跃度。我们在欣喜的同时，更多的是感恩，觉得自己应该对得起大家的这份关注和信任，继续做出更好的产品给大家。除了之前提到的各方面细节和感触，将来我们还有很多地方值得改进</p><ol><li>首先是把文档和网站做得更好，经过项目初期的摸爬滚打之后，我们对文档和网站本身也有了新的认识，同时我们有了更多的精力在这方面，所以未来我们会重新梳理我们的文档和网站，希望以一个更好的面膜提供给广大开发者</li><li>促进交流：除了 github issues 和 gitter，我们希望随着开发者诉求和参与程度的增加不断引入效果更好效率更高的交流和协作方式，比如 Playground 网站、Marketplace 之类的设想目前已经提上了日程</li><li>更透明：除了 proposal 的讨论透明化之外，我们会把整个团队的 Roadmap 也透明化，同时拿出更加民主的决策机制，让所有的开发者一同参与核心团队的决策和迭代计划</li><li>我们希望毫无保留的把我们的心得经验教训全部分享给希望在开源社区有所作为的朋友们，带动更多的开源实践，不论是阿里内部的，还是整个开源社区范围内的</li></ol><h3 id="最后的展望"><a href="#最后的展望" class="headerlink" title="最后的展望"></a>最后的展望</h3><p>借近期参加开源中国源创汇和JSConf的活动，也给了我一个机会从开源经历的角度重新审视了一些自己和团队做的事情。同时 Weex 在 github 的 star 也即将迈过 6000 大关，有一些感触，分享给大家。未来我们会继续努力，用自己的实际行动。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;mark&gt;本文早些时候发表在 weexteam 的博客 &lt;a href=&quot;https://github.com/weexteam/article/issues/73&quot;&gt;https://github.com/weexteam/article/issues/73&lt;/a&gt;&lt;/m
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Weex 在 JS Runtime 内的多实例管理</title>
    <link href="https://jiongks.name//blog/weex-multi-instance-runtime/"/>
    <id>https://jiongks.name//blog/weex-multi-instance-runtime/</id>
    <published>2016-08-31T11:17:00.000Z</published>
    <updated>2016-08-31T11:17:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><mark>本文早些时候发表在 weexteam 的博客 <a href="https://github.com/weexteam/article/issues/71">https://github.com/weexteam/article/issues/71</a></mark></p><p>Weex 的技术架构和传统的客户端渲染机制相比有一个显著的差别，就是引入了 JavaScript，通过 JS Runtime 完成一些动态性的运算，再把运算结果和外界进行通信，完成界面渲染等相关操作指令。而客户端面对多个甚至可能同时共存的 Weex 页面时，并没有为每个 Weex 页面提供各自独立的 JS Runtime，相反我们只有一个 JS Runtime，这意味着所有的 Weex 页面共享同一份 JS Runtime，共用全局环境、变量、内存、和外界通信的接口等等。这篇文章会循序渐进的介绍 Weex JS Runtime 这部分的内容，大概的章节设计是这样的：</p><ol><li>为什么需要多实例</li><li>多实例管理面临的挑战</li><li>解决问题的思路</li><li>几个特殊处理的地方</li><li>总结</li></ol><h3 id="为什么在-JS-Runtime-内部手动管理多实例？"><a href="#为什么在-JS-Runtime-内部手动管理多实例？" class="headerlink" title="为什么在 JS Runtime 内部手动管理多实例？"></a>为什么在 JS Runtime 内部手动管理多实例？</h3><p>如果只用一个词来回答，那就是“性能”</p><p>如果要用一段话来回答：手机上的资源是很宝贵的，包括CPU、内存、电量等等，而 Weex 团队从设计初期就决定以页面为单位对产品实现进行划分，一个完整的应用是多个相互独立解耦的页面通过一定的路由规则和链接跳转互联起来组合而成。所以为每个页面都单独提供一份 JS Runtime 代价还是比较昂贵的，这会引起大量的资源开销，手机发烫，反应迟钝，甚至应用或操作系统的崩溃。尤其是在国内一些中低端机型上面，反应尤其明显。</p><p>从另外一个角度讲，我们通过同一个 JS Runtime，可以更直接方便的做一些运行时的资源共享，比如 JS Framework 的初始化过程，只需要应用启动的时候执行一次就可以了，不必每个页面被打开的时候才进行。目前 JS Framework 的启动过程一般会在几百毫秒不等，相当于每个页面打开的时候，这几百毫秒都被节省下来了。</p><h3 id="多实例管理的-JS-Runtime-需要额外关注哪些问题？"><a href="#多实例管理的-JS-Runtime-需要额外关注哪些问题？" class="headerlink" title="多实例管理的 JS Runtime 需要额外关注哪些问题？"></a>多实例管理的 JS Runtime 需要额外关注哪些问题？</h3><p>首先不同的 Weex 页面肯定需要执行各自的 JavaScript 运算，完成各自的 native 指令收发。所以如何避免多个 Weex 页面在同一个 JS Runtime 里相互“打架”就变得至关重要。</p><p>这里的“打架”有以下几个细节：</p><ul><li>数据和状态的记录，能够正确的完成并且不会被其它页面的运算所干扰或截获</li><li>和 native 之间的收发指令或通信，能够准确的调度不同的 native 端页面</li><li>对系统资源的利用，遇到大运算量的页面时，其它页面有机会快速得到响应</li></ul><p>除了“打架”的问题之外，传统 HTML5 页面里，每个 JS Runtime 的生命周期是对应页面本身的生命周期的，相对是个短效的实例，而且一旦页面被关闭，对应这个页面的 JS Runtime 就可以大方的 kill 掉，没有任何后顾之忧；而 Weex 的 JS Runtime 需要在应用被开启之后至始至终存在并不间断工作，所以长期运转的内存管理也变成了一个不得不正视的问题。</p><h3 id="Weex-解决上述问题的过程"><a href="#Weex-解决上述问题的过程" class="headerlink" title="Weex 解决上述问题的过程"></a>Weex 解决上述问题的过程</h3><ul><li>首先，我们会为每个新打开的 Weex 页面创建一个唯一的 instance id</li><li>其次，JS Runtime 里所有的 native 通信接口，不管是发送还是接收，全部需要传递 instance id 作为第一个参数，这样 JS Runtime 和 native 端都可以快速准确的识别并分发给每个 Weex 页面，比如：<ul><li><code>createInstance(id, code, config, data)</code>：创建一个新的 Weex 页面，通过一整段 Weex JS Bundle 的代码，在 JS Runtime 开辟一块新的空间用来存储、记录和运算</li><li><code>sendTasks(id, tasks)</code>：从 JS Runtime 发送指令到 native 端</li><li><code>receiveTasks(id, tasks)</code>：从 native 端发送指令到 JS Runtime</li></ul></li><li>然后，我们根据不同的 instance id 在 JS Runtime 里进行独立的运算和数据、状态记录。这里我们通过 JavaScript 里的闭包原理把不同实例的运算和数据状态管理隔离在了不同的闭包里，达到相互不“打架”的目的。</li></ul><h4 id="初级形态"><a href="#初级形态" class="headerlink" title="初级形态"></a>初级形态</h4><p>形如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// old version of Weex JS Runtime</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createInstance</span>(<span class="params">id, code</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> customComponents = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">define</span>(<span class="params">name, definition</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// todo: register a weex component in this Weex instance</span></span><br><span class="line">    ...</span><br><span class="line">    customComponents[name] = definition</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bootstrap</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// todo: start to render this Weex instance from a certain named component</span></span><br><span class="line">    ...</span><br><span class="line">    sendTasks(id, [...])</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// run</span></span><br><span class="line">  <span class="built_in">eval</span>(code)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在闭包中设置了这么几个东西，保障隔离效果：</p><ol><li><code>define</code>: 用来自定义一个复合组件</li><li><code>bootstrap</code>: 用来以某个复合组件为根结点渲染页面</li></ol><p>这样的话，假设有一个 Weex 页面，它的代码是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码，并不能实际运行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A Weex JS Bundle File</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// define a component named `foo`</span></span><br><span class="line">define(<span class="string">&#x27;foo&#x27;</span>, &#123;</span><br><span class="line">  type: <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">  children: [</span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="string">&#x27;text&#x27;</span>, <span class="attr">attr</span>: &#123; <span class="attr">value</span>: <span class="string">&#x27;Hello World&#x27;</span> &#125;&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// render the page with `foo` component</span></span><br><span class="line">bootstrap(<span class="string">&#x27;foo&#x27;</span>)</span><br></pre></td></tr></table></figure><p>那么 Weex 页面里的 <code>define</code> 和 <code>bootstrap</code> 表面上是全局方法，实际上只会针对当前的 Weex instance 在一个更小的作用域下执行，而不会干扰或污染全局环境或其它 Weex 页面。</p><p>这是我们最初的版本的形态。</p><h4 id="配合更开放的前端包管理工具"><a href="#配合更开放的前端包管理工具" class="headerlink" title="配合更开放的前端包管理工具"></a>配合更开放的前端包管理工具</h4><p>随着 Weex JS Framework 代码的不断演进，功能也逐渐丰富起来，上层的 Weex 页面也写得越来越复杂，之前简单的 <code>define</code> + <code>bootstrap</code> 已经满足不了工程上的需求和设想了。这个时候我们需要引入前端资源包管理的概念，而且拥抱现有的各种成熟的包管理规范和工具。这其中包括 AMD、CMD、CommonJS、ES6 Modules 等等。这个时候 <code>define</code> 和 <code>bootstrap</code> 这两个名字就显得起得有点太大了，尤其是 <code>define</code>，和 AMD 里的语法重叠，所以和很多兼容 AMD 语法的打包工具都会产生冲突。所以我们逐步把这些方法转变成了带有 Weex 特殊前缀的方法：</p><ol><li><code>__weex_define__</code>: <code>define</code> 的别名，用来自定义一个复合组件</li><li><code>__weex_bootstrap__</code>: <code>bootstrap</code> 的别名，用来以某个复合组件为根结点渲染页面</li></ol><p>同时我们可以借助各种打包工具把 Weex 页面拆成多个文件开发和维护，然后打包成一个文件完成发布和运行，以 webpack 为例，上述的例子会打包生成类似：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码，并不能实际运行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/******/</span> (<span class="function"><span class="keyword">function</span>(<span class="params">modules</span>) </span>&#123; <span class="comment">// webpackBootstrap</span></span><br><span class="line"><span class="comment">/******/</span>  <span class="comment">// The module cache</span></span><br><span class="line"><span class="comment">/******/</span>  <span class="keyword">var</span> installedModules = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******/</span>  <span class="comment">// The require function</span></span><br><span class="line"><span class="comment">/******/</span>  <span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******/</span>    <span class="comment">// Check if module is in cache</span></span><br><span class="line"><span class="comment">/******/</span>    <span class="keyword">if</span>(installedModules[moduleId])</span><br><span class="line"><span class="comment">/******/</span>      <span class="keyword">return</span> installedModules[moduleId].exports;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******/</span>    <span class="comment">// Create a new module (and put it into the cache)</span></span><br><span class="line"><span class="comment">/******/</span>    <span class="keyword">var</span> <span class="built_in">module</span> = installedModules[moduleId] = &#123;</span><br><span class="line"><span class="comment">/******/</span>      <span class="built_in">exports</span>: &#123;&#125;,</span><br><span class="line"><span class="comment">/******/</span>      id: moduleId,</span><br><span class="line"><span class="comment">/******/</span>      loaded: <span class="literal">false</span></span><br><span class="line"><span class="comment">/******/</span>    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******/</span>    <span class="comment">// Execute the module function</span></span><br><span class="line"><span class="comment">/******/</span>    modules[moduleId].call(<span class="built_in">module</span>.exports, <span class="built_in">module</span>, <span class="built_in">module</span>.exports, __webpack_require__);</span><br><span class="line"></span><br><span class="line"><span class="comment">/******/</span>    <span class="comment">// Flag the module as loaded</span></span><br><span class="line"><span class="comment">/******/</span>    <span class="built_in">module</span>.loaded = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******/</span>    <span class="comment">// Return the exports of the module</span></span><br><span class="line"><span class="comment">/******/</span>    <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line"><span class="comment">/******/</span>  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/******/</span>  <span class="comment">// expose the modules object (__webpack_modules__)</span></span><br><span class="line"><span class="comment">/******/</span>  __webpack_require__.m = modules;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******/</span>  <span class="comment">// expose the module cache</span></span><br><span class="line"><span class="comment">/******/</span>  __webpack_require__.c = installedModules;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******/</span>  <span class="comment">// __webpack_public_path__</span></span><br><span class="line"><span class="comment">/******/</span>  __webpack_require__.p = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******/</span>  <span class="comment">// Load entry module and return exports</span></span><br><span class="line"><span class="comment">/******/</span>  <span class="keyword">return</span> __webpack_require__(<span class="number">0</span>);</span><br><span class="line"><span class="comment">/******/</span> &#125;)</span><br><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"><span class="comment">/******/</span> ([</span><br><span class="line"><span class="comment">/* 0 */</span></span><br><span class="line"><span class="comment">/***/</span> <span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span>, <span class="built_in">exports</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  __weex_define__(<span class="string">&#x27;foo&#x27;</span>, &#123;</span><br><span class="line">    type: <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">    children: [</span><br><span class="line">      &#123; <span class="attr">type</span>: <span class="string">&#x27;text&#x27;</span>, <span class="attr">attr</span>: &#123; <span class="attr">value</span>: <span class="string">&#x27;Hello World&#x27;</span> &#125;&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  __weex_bootstrap__(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/***/</span> &#125;</span><br><span class="line"><span class="comment">/******/</span> ]);</span><br></pre></td></tr></table></figure><p></div></p><h4 id="从-eval-到-new-Function"><a href="#从-eval-到-new-Function" class="headerlink" title="从 eval 到 new Function"></a>从 <code>eval</code> 到 <code>new Function</code></h4><p>之后我们在最终执行 Weex JS Bundle 代码时，从略显简陋的 <code>eval</code> 命令改写成了 <code>new Function</code>，即：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// old version</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">define</span>(<span class="params"></span>) </span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bootstrap</span>(<span class="params"></span>) </span>&#123;...&#125;</span><br><span class="line"><span class="built_in">eval</span>(code)</span><br><span class="line"></span><br><span class="line"><span class="comment">// new version</span></span><br><span class="line"><span class="keyword">import</span> &#123; aaa, bbb &#125; <span class="keyword">from</span> <span class="string">&#x27;xxx&#x27;</span> <span class="comment">// place and name your methods as you like</span></span><br><span class="line"><span class="keyword">const</span> fn = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;define&#x27;</span>, <span class="string">&#x27;bootstrap&#x27;</span>, code)</span><br><span class="line">fn(aaa, bbb)</span><br></pre></td></tr></table></figure><p>用 <code>new Function</code> 的前几个参数定义了即将执行的 Weex JS Bundle 中“伪装”的几个全局变量或全局方法，然后运行的时候把那些背后的“伪装”传递进去，形式上更灵活，运行时更安全。</p><p>同时也是因为闭包中需要准备的变量和方法也逐渐多起来了，<code>new Function</code> 的写法更便于清晰的管理和对应这些内容。</p><h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><p>可能很多同学注意到了，不论是 <code>eval</code> 还是 <code>new Function</code> 其实效率都是不高的，为什么还要这样用呢？主要的原因还是因为我们需要动态的为每个 Weex 页面创造这样的闭包。后来在 native 端我们还想到了一些变通的优化办法，即在 native 端将 Weex JS Bundle 代码包装在一个闭包里，再丢给 JavaScript 去执行。所以，如果一个 Weex JS Bundle 大代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码，并不能实际运行</span></span><br><span class="line"></span><br><span class="line">__weex_define__(<span class="string">&#x27;foo&#x27;</span>, &#123;</span><br><span class="line">  type: <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">  children: [</span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="string">&#x27;text&#x27;</span>, <span class="attr">attr</span>: &#123; <span class="attr">value</span>: <span class="string">&#x27;Hello World&#x27;</span> &#125;&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">__weex_bootstrap__(<span class="string">&#x27;foo&#x27;</span>)</span><br></pre></td></tr></table></figure><p>而客户端现在要基于这个 Weex JS Bundle 创建一个页面，instance id 为 <code>x</code>，那么客户端会先为这段代码加上特殊的头和尾：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码，并不能实际运行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 特殊的头部代码</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">global</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> env = <span class="built_in">global</span>.prepareInstance(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> (<span class="params">__weex_define__, __weex_bootstrap__</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 特殊的头部代码</span></span><br><span class="line"></span><br><span class="line">__weex_define__(<span class="string">&#x27;foo&#x27;</span>, &#123;</span><br><span class="line">  type: <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">  children: [</span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="string">&#x27;text&#x27;</span>, <span class="attr">attr</span>: &#123; <span class="attr">value</span>: <span class="string">&#x27;Hello World&#x27;</span> &#125;&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">__weex_bootstrap__(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特殊的尾部代码</span></span><br><span class="line">  &#125;)(env.define, env.bootstrap)</span><br><span class="line">&#125;)(<span class="built_in">this</span>)</span><br><span class="line"><span class="comment">// 特殊的尾部代码</span></span><br></pre></td></tr></table></figure><p>这样的话我们先通过 <code>prepareInstance(&#39;x&#39;)</code> 创建一个属于 <code>x</code> 这个 id 的方法，然后通过 <code>function (__weex_define__, __weex_bootstrap__)</code> 创造一个闭包，把 JS Bundle 的源代码放进去，效果和之前的实现是等价的，但是由于没有用到 <code>eval</code> 和 <code>new Function</code>，性能有了一定的提升，在我们实验室数据中，JavaScript 运算的时间缩短了 10%~25%。</p><p>当然，由于在浏览器的环境下，我们没有机会在执行 JavaScript 之前对内容进行高性能的处理，所以 HTML5 Renderer 还没有办法通过这样的改造提升执行效率，在这方面我们还会继续探索。</p><h4 id="其它多实例管理接口设计"><a href="#其它多实例管理接口设计" class="headerlink" title="其它多实例管理接口设计"></a>其它多实例管理接口设计</h4><p>包括上述提到的 <code>createInstance()</code> 接口在内，JS Runtime 还提供了以下几个和 native 通信的方式：</p><p>首先是 native 配置的导入：</p><ul><li><code>registerComponents(components)</code></li><li><code>registerModules(modules)</code></li></ul><p>这两个 API 用来让 JS Runtime 知道当前 Weex 支持哪些原生组件和原生的功能模块，及其相关的细节。</p><p>其次是实例的生命周期管理：</p><ul><li><code>createInstance(id, code, ...)</code></li><li><code>refreshInstance(id, data)</code></li><li><code>destroyInstance(id)</code></li></ul><p>这三个 API 用来让 JS Runtime 知道每一个页面的创建和销毁的时机，特别的，我们还提供了一个 <code>refreshInstance</code> 的接口，可以便捷的更新这个 Weex 页面的“顶级”根组件的数据。</p><p>最后，每个 Weex 页面在具体工作的时候会更频繁的使用到下面这两个 API</p><ul><li><code>sendTasks(id, tasks)</code>：从 JS Runtime 发送指令到 native 端</li><li><code>receiveTasks(id, tasks)</code>：从 native 端发送指令到 JS Runtime</li></ul><p>这其中，<code>sendTasks</code> 中的指令会以 native 的功能模块进行分类和标识，比如 DOM 操作 (<code>dom</code> 模块)、弹框操作 (<code>modal</code> 模块) 等，每个功能模块又提供了多种方法可以调用，一个指令其实就是由指定的功能模块名、方法名以及参数决定的。比如一个 DOM 操作的指令 <code>sendTasks(id, [&#123; module: &#39;dom&#39;, method: &#39;removeElement&#39;, args: [elementRef]&#125;])</code>。</p><p><code>receiveTasks</code> 中的指令一共有两种，一种是 <code>fireEvent</code>，相应客户端在某个 DOM 元素上触发的事件，比如 <code>fireEvent(titleElementRef, &#39;click&#39;, eventObject)</code>；而另一种则是 <code>callback</code>，即前面功能模块调用之后产生的回调，比如我们通过 <code>fetch</code> 接口向 native 端发送一个 HTTP 请求，并设置了一个回调函数，这个时候，我们会先在 JavaScript 端为这个回调函数生成一个 <code>callbackId</code>，比如字符串 <code>&quot;x&quot;</code>——其实我们实际上发送给 native 端的是这个 <code>callbackId</code>，当请求结束之后，native 需要把请求结果返还给 JS Runtime，为了能够前后对得上，这个回调最终会成为类似 <code>callback(callbackId, result)</code> 的格式。</p><p>至此，我们就拥有了 7 个主要的接口，来完成 native 和 JS Runtime 之间的通信，同时可以做到多实例之间的隔离。</p><h3 id="几个特殊处理的地方"><a href="#几个特殊处理的地方" class="headerlink" title="几个特殊处理的地方"></a>几个特殊处理的地方</h3><p>篇幅有限，所有问题不能一一展开，这里提几个我们比较有心得的地方</p><h4 id="如何避免某个页面大数据量通信阻塞其它页面的通信"><a href="#如何避免某个页面大数据量通信阻塞其它页面的通信" class="headerlink" title="如何避免某个页面大数据量通信阻塞其它页面的通信"></a>如何避免某个页面大数据量通信阻塞其它页面的通信</h4><p>绝对的避免和杜绝是很难的，我们通过以下集中方式尝试缓解和回避这种现象出现，部分想法还在论证当中：</p><ol><li>持续优化 JS 代码的算法实现，这个是肯定要做的。</li><li>如果一个页面的内容在运算到一半的时候，用户就关掉了这个页面，尽管不能像关闭一个浏览器标签时那样杀掉这个 JS Runtime，但是可以通过在 <code>sendTasks</code> 的时候返回一个特殊的值来提示 JS 代码可以省去后续的计算，让整个 JS 阻塞的状态立即恢复。</li><li>部分用户交互可以跳过 JS 执行逻辑直接相应，比如为按钮监听点击事件，并在事件被触发的时候执行 <code>openURL</code> 这个打开网址的命令是个很长的链路，但如果我们支持 <code>&lt;a href&gt;</code> 这样的标签，用户点击链接的时候，页面可以不经过 JS 运算直接跳走，这样回避了 JS 阻塞带来的问题。</li><li>通过用户体验上的一些技巧尽量回避界面一直无相应致使用户一直等待的体验，比如通过伪类规则让用户点击一个按钮的时候第一时间感受到“hover”效果等。</li><li>可以考虑“双核” JS Runtime，永远有一个闲置的随时等待打开新页面的 JS Runtime，这样在页面切换的时候，新页面的加载和运算不会被旧页面阻塞。当然这样做存在对架构和资源的挑战。</li></ol><p>更多的思路和想法等待大家的挖掘和探讨。</p><h4 id="安全、隐私和稳定性"><a href="#安全、隐私和稳定性" class="headerlink" title="安全、隐私和稳定性"></a>安全、隐私和稳定性</h4><p>其实现在在 Weex 页面里，不经过声明给一个变量赋值还是会产生全局环境的污染，我们短期只能通过宣导的方式，教育开发者避免使用全局变量——这在传统的 HTML5 和 JavaScript 开发中都是特别不推荐的做法。</p><p>长期来看，我们可以提供一些发布前的语法检测工具，帮助开发者更好的驾驭自己的代码。</p><p>从隐私性的角度，如果你的客户端是多个团队共同研发的，相互之间希望不被打扰，我们也可以考虑引入浏览器中比较广泛实践的“同源策略”，根据 JS Bundle URL 的域名区分对待。</p><h4 id="更高更复杂的课题：支持多个-Framework-共存"><a href="#更高更复杂的课题：支持多个-Framework-共存" class="headerlink" title="更高更复杂的课题：支持多个 Framework 共存"></a>更高更复杂的课题：支持多个 Framework 共存</h4><p>让 Weex 能够支持多种 Framework 共存，既是满足多方业务团队不同技术栈和需求的一个重要决定，同时也是尊重前端社区固有的开放自由的精神，更是让 Weex 在快速更迭的前端技术栈中立于不败之地的基础。</p><p>早期的 Weex 是重度依赖我们自身研发的 JS Framework 的，它基于 Vue 1.x 的数据监听机制，配合 Weex virtual-DOM APIs 进行数据绑定，并沿用了 mustache 的经典模板语法。现如今，Vue 2.0 迎来了很多颠覆式的革新和改进、React 也被越来越多的工程师所接受，Angular、Zepto/jQuery、VanillaJS 也都有众多的前端开发者在使用。所以我们在支持 native 端多实例指令分发的同时，也支持了多 JS Framework 本地部署并相互隔离，可以支持不同的 Weex 页面基于各自的 JS Framework 开发运行。</p><p>首先我们约定，每个 Weex 页面的 JS Bundle 第一行需要出现一行特殊格式的注释，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123; &quot;framework&quot;: &quot;Vue&quot; &#125;</span></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>它能够识别当前 Weex 页面所对应的 JS Framework，比如这个例子是需要 Vue 来解析的。如果没有识别出合法的注释，则被认为对应到默认的 Weex JS Framework。</p><p>然后把每个 Weex 页面及其对应的 JS Framework 名称的关联关系记录下来。</p><p>最后把上面提到的 JS 和 native 通信的 <code>createInstance</code>, <code>refreshInstance</code>, <code>destroyInstance</code>, <code>sendTasks</code>, <code>receiveTasks</code> 等接口在每个 JS Framework 中都封装一遍，然后每次这些全局方法被调用的时候，JS 都可以根据记录下来的页面和 JS Framework 的对应关系找到相应的 JS Framework 封装的方法，并完成调用。</p><p>这样每个 JS Framework，只要：1. 封装了这几个接口，2. 给自己的 JS Bundle 第一行写好特殊格式的注释，Weex 就可以正常的运行基于各种 JS Framework 的 页面了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这篇文章主要介绍了 Weex 在 JS Runtime 这个环节的一些现状，以及它的来龙去脉，同时介绍了一些心得经验和特别的地方。篇幅有限，有些东西描述的还是比较简略，感兴趣的同学可以移步我们的 github 了解更多细节，同时欢迎大家一起参与到我们的开源项目建设当中来！</p><p>谢谢</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;mark&gt;本文早些时候发表在 weexteam 的博客 &lt;a href=&quot;https://github.com/weexteam/article/issues/71&quot;&gt;https://github.com/weexteam/article/issues/71&lt;/a&gt;&lt;/m
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>我理解的 SPA</title>
    <link href="https://jiongks.name//blog/spa-i-understand/"/>
    <id>https://jiongks.name//blog/spa-i-understand/</id>
    <published>2016-08-27T00:00:00.000Z</published>
    <updated>2016-08-27T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>如题，SPA (Single Page Application - 单页应用) 这个话题已经在 Weex 社区讨论了有一段时间，在传统的前端开发领域中大家也在长期探讨这个话题。这里谈谈我个人的理解和看法。</p><h3 id="SPA-的背景"><a href="#SPA-的背景" class="headerlink" title="SPA 的背景"></a>SPA 的背景</h3><p>SPA 往往和 Router、页面间通信、页面间数据共享这些词汇联系在一起，不少同学直接问到这些词汇，实际上都是以 SPA 为前提的，因为脱离 SPA 的概念，这些词汇将失去它原有的意义，或者变成了完全不同的东西。</p><p>那 SPA 不是理所当然、天经地义、不容挑战的吗？干嘛要脱离 SPA 的概念讨论这些问题？</p><p>我觉得不是</p><p>SPA 背后的命题是如何管理复杂的页面关系，最终构成一个产品的整体。传统的页面之间是通过简单粗暴的“页面跳转”和“浏览器前进/后退”建立联系的，SPA 提出的观念是在浏览器中模拟页面的跳转、切换和前进/后退，相关的很多周边命题也随之而生。</p><p>(其实你不觉得这也是个”全家桶”么……)</p><p>所以我们先把问题回归到如何管理复杂的页面关系</p><h3 id="如何管理复杂的页面关系"><a href="#如何管理复杂的页面关系" class="headerlink" title="如何管理复杂的页面关系"></a>如何管理复杂的页面关系</h3><p>我觉得有以下几个子命题 —— <em>在这之前，我想先把接下来所有的讨论，从形态上收敛到手机应用，PC 端的暂时不涉及。</em></p><h4 id="如何拆分页面"><a href="#如何拆分页面" class="headerlink" title="如何拆分页面"></a>如何拆分页面</h4><p>怎么把一个完整的产品以页面为维度进行拆分，这里是有学问的。</p><p>其中最关键的一个认知问题就是页面的颗粒度是否就是整个手机屏幕同时可以呈现的所有内容？</p><p>如果是，那么页面本身的结构就是简单的一维模型，即所有的页面都可以完全独立工作运行。</p><p>如果不是，那么有可能某个页面是另外一个页面的一部分，两者之间有包含关系。这样的话页面结构就变成了多维的。</p><p>在 PC 上，答案显然是后者，因为 PC 的屏幕比手机要大得多，所有页面都要整屏更换和依赖，显然是不合理的，但是在手机屏幕上，我们有机会简化为前者。</p><h4 id="如何在工程上把不同的页面解耦"><a href="#如何在工程上把不同的页面解耦" class="headerlink" title="如何在工程上把不同的页面解耦"></a>如何在工程上把不同的页面解耦</h4><p>也可以从另外一个角度讲，不说怎么解耦，而是不同的页面之间保留了哪些耦合。</p><p>这个地方的设计直接决定了大规模并行研发产品的可能性和实际的效率效果</p><h4 id="独立页面之间是如何建立联系的"><a href="#独立页面之间是如何建立联系的" class="headerlink" title="独立页面之间是如何建立联系的"></a>独立页面之间是如何建立联系的</h4><ul><li>如何跳转和切换：在手机上常见的跳转和切换就是 navigator 和 tabbar 两种模式，一种是产生历史记录的，有栈式结构的；另一种则是平级切换的，页面之间是并列关系</li><li>如何传递信息：开发者是否有机会在一个页面调用到另外一个页面的方法或接口</li><li>如何共享数据：用户在前一个页面提交了个人信息，如何体现在下一个页面上</li></ul><h3 id="看看-SPA-是怎么解决这些问题的"><a href="#看看-SPA-是怎么解决这些问题的" class="headerlink" title="看看 SPA 是怎么解决这些问题的"></a>看看 SPA 是怎么解决这些问题的</h3><ul><li>拆分页面的方式：如最一开始所描述的，SPA 会在浏览器中模拟页面切换和跳转，因此他需要路由控制，而控制的方式就是把每个页面都定义一个 URL，当页面切换或跳转时，URL 就会发生相应的变化，同理我们直接打开不同 URL 的时候，浏览器可以准确定位到不同的页面。常见的 URL 区分方式包括不同的路径 (path)、不同的参数 (query) 和不同的锚点 (hash) 等。所以如果父页面中有子页面存在不同的状态，则 URL 设计应该在父页面的基础上追加不同的 path/query/hash 来达到定位子页面状态的目的。</li><li>工程耦合度：首先 SPA 可以通过 URL 精准定位到不同的页面，就决定了它的路由规则是中心化约定的，当页面比较多了之后，为了避免冲突，每新建一个或一组页面都要有中心化注册的过程；另外每个页面中的代码从资源加载和管理的角度是中心化耦合的 (当然有具体优化的解法，比如按需加载等，这里不展开了)</li><li>页面之间的联络方式<ul><li>跳转和切换：主要是通过代理浏览器的跳转、前进、后退、替换等行为，然后自行在页面内完成相应的变化，几个明显的入口包括 <code>&lt;a&gt;</code> 链接、<code>location</code> 设置、历史管理 API等</li><li>信息传递：典型的场景就是子页面和父页面之间同步变化，一般通过在 SPA 框架层面提供通信机制，而且通常是消息广播的模型</li><li>数据共享：现在普遍被接受和认同的是基于 Flux 架构的设想，开辟一块全局共享的 Store，这样应用从 A 页面切换或跳转到 B 页面的时候，可以通过这块全局的 Store 来同步数据和状态</li></ul></li><li>SPA 这样的方案的特点或局限<ul><li>过渡体验：SPA 因为代理了所有页面切换和跳转的行为，所有整个页面之间过渡的过程是可以定制的，比如左滑右滑、淡入淡出等等，结合一些 CSS3 变换的效果，可以做得很酷炫，传统页面跳转是很难做出这种效果的</li><li>首次加载：因为有中心化的路由管理等相关逻辑，同时 SPA 首页首次加载往往需要消耗更长的时间，如果用户的回头率不高的话，总体上这个其实是个劣势</li><li>长效 JS Runtime：这意味着用户会长期开着同一个页面，JS 的内存控制是一个非常敏感的命题，一不小心写出个内存泄漏，整个应用就会越跑越慢直到存尽应亡</li><li>需要手动处理 Security/Privacy 等问题：因为本质上所有的页面即便设计和研发商再独立，它也是运行在同一个浏览器页面中，没有绝对的信息和资源的隔离</li></ul></li></ul><h3 id="手机淘宝是怎么解决这些问题的"><a href="#手机淘宝是怎么解决这些问题的" class="headerlink" title="手机淘宝是怎么解决这些问题的"></a>手机淘宝是怎么解决这些问题的</h3><p>手机淘宝的工程传统是一种非常简单粗暴直接有效的理念 —— 可能你看下来会有这种感觉</p><p>首先我们没有实践 SPA —— 准确的讲鲜有成功实践的 SPA 案例，但解决上述问题有一些自己细节上的思考</p><ul><li>拆分页面的方式：没有子页面的概念，父页面某个地方不同的状态均由子页面自行设计体现，不做中心化设计和管理</li><li>工程耦合度：每个页面都是完全不同的浏览器实例，所以工程上是以页面为颗粒度完全解耦的，不同页面可以使用完全不同的前端框架、资源策略、内部通信方式等</li><li>页面之间的联络方式<ul><li>跳转和切换：就是浏览器的跳转，额外的我们会通过 SPM/SCM 参数在服务端直接统计出流量转化的关系，是纯天然无污染的，SPA 做这个事情就需要另外想办法了</li><li>信息传递：因为没有父页面子页面的问题了，所以这种需求几乎是不存在的，如果真的有父子页面的关系存在，一般会是 <code>&lt;iframe&gt;</code> 可以使用 Web Messaging API 来进行通信，但总体上确实场景非常少</li><li>数据共享：首先 Flux 的全局 Store 应该不太排的上用场，因为页面之间是完全隔离的，所以这里有三个套路：1 是通过 URL 传参数；2 是通过 W3C 的一系列本地持久化存储机制，包括 cache/localStorage/WebSQL/IndexedDB/appcache 等；3 可以通过 hybrid API 或服务器记录状态并进行中转。这里额外强调一下，1 和 3 是我们使用最多的方式，2 反而用得很少，因为对于手机淘宝这种体量的产品，本地空间很快就被塞爆了，所以业务上重度依赖这种技术不是很明智的选择</li></ul></li><li>手机淘宝方案的特点或局限<ul><li>native过渡效果：页面之间的过渡效果是不可定制的，这是一个局限</li><li>资源重复加载：不会面临首次加载内容过多的问题，但是不同的页面资源会重复加载，当然就像 SPA 的方案一样，这里也有很多预加载或缓存的上层机制可以缓解这一矛盾</li><li>短效 JS Runtime：比较省心，反正页面跳走之后旧页面的相关资源就彻底回收了</li><li>天生 Security/Privacy：页面之间没有直接共享的系统资源，而且基于 W3C 的同源策略，所以也比较省心</li></ul></li></ul><p>所以大家会发现，我们为了更好的工程实践和大规模并行研发方面做了一定的取舍</p><h3 id="Weex-打算怎么解决这些问题"><a href="#Weex-打算怎么解决这些问题" class="headerlink" title="Weex 打算怎么解决这些问题"></a>Weex 打算怎么解决这些问题</h3><p>经过上述分析和论述，我们也逐步滤清了 Weex 在这个复杂问题上的思路：如何解决 Weex 中路由管理的问题？如何在 Weex 上进行 SPA 实践？如何让 Weex 页面之间通信或共享数据？其实面对这么多看似复杂混乱的问题，只要从上述几个角度抓住重点问题，提出关键解法，就可以把复杂问题逐一解开。</p><ul><li>拆分页面的方式：提供 <code>&lt;web&gt;</code>/<code>&lt;embed&gt;</code> 这样的组件，可以管理子页面，但这里我们延续了手机淘宝对待子页面状态定位的看法，不做中心化的设计，每个页面可以自由定义识别规则 —— 当然这个规则范围就不包含 path 了 —— 因为这需要模拟页面的跳转和切换，所以只有 query 和 hash 可以识别</li><li>工程耦合度：每个页面独立研发，完全解耦，同时可以利用 SPM/SCM 数据统计机制，和手机淘宝的工程实践经验保持一致</li><li>页面之间的联络方式<ul><li>跳转和切换：目前就两个入口 <code>&lt;a&gt;</code> 链接和 <code>openURL()</code> 方法，对于 <code>&lt;web&gt;</code>, <code>&lt;embed&gt;</code> 中产生的跳转和切换命令，我们目前还没有具体的设计和实现，将来可以提供类似 <code>a[target]</code> 的配置项，让页面跳转和切换的时候可以指定父页面或子页面作为目标</li><li>信息传递：目前是没有办法传递的，未来可以设计一个类似 SPA 感觉的系统级的消息广播机制来满足业务上的需求</li><li>数据共享：同样的我们推荐的也是手机淘宝的最佳实践：URL 参数传递、本地持久化存储、服务端中转；同时，由于 Weex 的 JS Runtime 是唯一的，这也就意味着我们未来是有机会在系统层面提供类似 Flux 架构中全局 Store 的东西供开发者使用，但是这里随之而来的隐患也是比较多的，而且一旦这个功能进入系统层面，所有的问题都会被无限放大，所以我们在这方面持谨慎态度。</li></ul></li><li>该方案整体的特点或局限<ul><li>过渡效果：我们不可能像 SPA 那样完全用 CSS3 变换来定制页面之间的过渡效果，但是有机会归纳抽象几种常见的效果，供业务方选择，这样页面之间的过渡效果不至于像传统的浏览器效果那么生硬</li><li>资源重复加载：可以完全复用手机淘宝目前所有的最佳实践</li><li>长效 JS Runtime、Security/Privacy 问题：这方面我们和 SPA 面临的问题是相同的，目前这方面的问题我们不算解决的特别好，有很多工作需要做。也是因为如此，我们上述的系统级 Flux 架构和全局 Store 的方案需要三思而行</li></ul></li></ul><h3 id="接下来的-Actions"><a href="#接下来的-Actions" class="headerlink" title="接下来的 Actions"></a>接下来的 Actions</h3><p>最后总结下来，如果大家认可我们上述的设想和取舍的话，Weex 在应用级别的工程实践上还欠缺这么几个地方：</p><ol><li>提供子页面精确定位识别的最佳实践和必要的工具库或辅助库</li><li>提供类似 <code>a[target]</code> 的配置项，在页面跳转或切换时可以指定目标页面</li><li>系统级的全局消息广播机制，做到跨页面信息传递</li><li>抽象归纳几种常见的页面过渡效果，供上层业务选择和配置</li><li>有效控制长效 JS Runtime 存在的各种问题</li><li>最后的最后，非常谨慎的引入 Flux 架构中的全局 Store —— 其实系统级的 Store 和本地持久化存储只有一点点区别：就是 Store 是被进一步抽象且可以通过绑定机制自动触发视图更新的</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这里首先谈了谈个人对 SPA 的认识，同时觉得 SPA 背后的命题本质上是“如何管理复杂的页面关系”。然后列出了几个关键的维度，包括如何拆分页面、如何管理耦合、如何跳转和切换页面、页面间如何通信和数据共享等等，并对比了 SPA 在这方面的表现，和手机淘宝传统的实践经验和取舍判断，最后按照相同的思维模型得出了 Weex 在这方面的选择，列出了接下来的 Actions。在整个过程中，我们可能还是会在细节问题上展开更具体的讨论，届时我们可以再伺机探讨。</p><p>谢谢</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如题，SPA (Single Page Application - 单页应用) 这个话题已经在 Weex 社区讨论了有一段时间，在传统的前端开发领域中大家也在长期探讨这个话题。这里谈谈我个人的理解和看法。&lt;/p&gt;
&lt;h3 id=&quot;SPA-的背景&quot;&gt;&lt;a href=&quot;#SPA
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>我理解的 Flux 架构</title>
    <link href="https://jiongks.name//blog/flux-i-understand/"/>
    <id>https://jiongks.name//blog/flux-i-understand/</id>
    <published>2016-08-23T14:11:00.000Z</published>
    <updated>2016-08-23T14:11:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><mark>本文早些时候发表在 云栖社区 <a href="https://yq.aliyun.com/articles/59357">https://yq.aliyun.com/articles/59357</a></mark></p><p>之前 review 业务代码的时候就一直想说写一篇自己对 Flux 的理解和看法，不知不觉也过去蛮久了，于是这周末打起精神写了这么一篇。</p><p>这篇文章将谈一些我对 Flux 的理解和个人看法。如果您还不太了解什么是 Flux，请先移步<a href="http://facebook.github.io/flux/docs/overview.html">这里</a>。</p><p>另外文中没有特别大段的代码，以讨论架构设计和背后的道理为主，可能会显得有点枯燥，大家可以选个不太困的时候耐心读读看：）</p><h3 id="Flux-中的几个基本概念"><a href="#Flux-中的几个基本概念" class="headerlink" title="Flux 中的几个基本概念"></a>Flux 中的几个基本概念</h3><p>这是 Flux 官方提供的一张说明图：</p><p><img src="https://facebook.github.io/flux/img/overview/flux-simple-f8-diagram-with-client-action-1300w.png" alt=""></p><p>图中有四个名词：</p><ul><li>View</li><li>Store</li><li>Action</li><li>Dispatcher</li></ul><p>下面逐个以我的角度做个讲解：</p><p>首先 View 是视图，是用户看得见摸得着的地方，同时也是产生主要用户交互的地方，这个概念在 MVC 和 MVVM 架构中都是有的，有些观点认为虽然这几种架构里都有 View，但是定义不太一致，有细微的差别，我自己觉得这种差异确实是存在的，但在一开始这并不妨碍我们理解 View 这个名词。</p><p>然后是 Store，它对应我们传统意义上的 Data，和 MVC、MVVM 里的 Model 有一定对应关系。你问我它们为啥不直接叫 Data 算了，那这就是文化人和小老百姓表达方式的差别。当然了我只是想尽量降低理解成本，尝试用比较通俗的说法把问题说清楚。</p><p>然后是 Action，这看上去是一个新概念，实际上我还是能找到一些帮助大家理解的名词，叫做 Event。就是一个结构化的信息，从一个地方传递到另一个地方，整个过程就是一个 Action/Event。</p><p>最后是 Dispatcher，多说一句，我觉得正是因为有了 Dispatcher 才让前面三个名词变得有新鲜感。也是理解 Flux 的关键。言归正传，Dispatcher 算是从 Action 触发到导致 Store 改变的镇流器。比一般架构设计里直接在“Event”逻辑中修改“Data”更“正规”。所以土得掉渣的 Event 变成了 Action，土得掉渣的 Data 变成了 Store，土得掉渣的 View 仍然是土得掉渣的 View。</p><h3 id="为什么多了-Dispatcher，这些-Store、View、Action-就变得神奇了呢？"><a href="#为什么多了-Dispatcher，这些-Store、View、Action-就变得神奇了呢？" class="headerlink" title="为什么多了 Dispatcher，这些 Store、View、Action 就变得神奇了呢？"></a>为什么多了 Dispatcher，这些 Store、View、Action 就变得神奇了呢？</h3><p>因为“正规”</p><p>传统 MVC 被 Flux 团队吐槽最深的，表面上是 Controller 中心化不利于扩展，实际上是 Controller 需要处理大量复杂的 Event 导致。这里的 Event 可能来自各个方向是 Flux 吐槽的第二个点，所以不同的数据被不同方向的不同类型的 Event 修改，数据和数据之间可能还有联系，难免就会乱。</p><p>所以和 Dispatcher 配合的 Store 只剩下了一个修改来源，和 Dispatcher 配合的 Action 只剩下了约定好的有限几种操作。一下子最混乱的地方变得异常“正规”了。架构复杂度自然就得到了有效的控制。</p><p>另外还有一个蛮好理解的点是：Action 不仅仅把修改 Store 的方式约束了起来，同时还加大了 Store 操作的颗粒度，让琐碎的数据变更变得清晰有意义。</p><p>另外，这两个地方抽象之后数据操作变得“无状态”了，所以可以根据 Action 的历史记录确定 Store 的状态。这个让很多撤销恢复管理等场景成为了可能。</p><p>综上所述，在 Flux 架构中，数据修改的颗粒度变大，更有语义；上层数据操作的行为更抽象化，碎片化程度降低。</p><h3 id="Flux-架构是-React-技术栈独占的吗？"><a href="#Flux-架构是-React-技术栈独占的吗？" class="headerlink" title="Flux 架构是 React 技术栈独占的吗？"></a>Flux 架构是 React 技术栈独占的吗？</h3><p>不是，只要在传统架构的基础上注重对数据操作和用户/客户端/服务器行为的抽象定义，Flux 架构中提到的各种好处大家都享受得到。</p><p><img src="http://img4.tbcdn.cn/L1/461/1/2187620899fa5a0c5c2934c6ed83691f6bf95a7c" alt="image" title="image"></p><p>我们就拿被 Flux 黑得最惨的那个“一大堆 V 和一大堆 M 只有一个 C”的例子好了，图中每个 View 找到不一样 Model 进行操作时，我们把这些操作抽象成 Action，然后通过中心化的逻辑找到相应的 Model 完成修改，其实就是 Flux 了。这里抽象出来的 Action 一定要和图中 Controller 能够接受到 Action 一样，没有什么特殊的地方。</p><p>基于这样的理解，Redux 提出了另外的对 Flux 架构的理解：</p><ol><li>首先 Store 是通过 Creator 创建出来的</li><li>每个 Store 都有自己的 state 用来记录当前状态</li><li>在创建 Store 的时候，通过 Reducer 把 state 和 action 的关系建立起来</li><li>后期通过在 Store 对象上 dispatch 不同的 action 达到对 state 的修改</li></ol><p>本质上同样是对数据操作和上层行为的抽象，另外从实现层面更加 functional。</p><p>Vuex 是基于 Vue.js 的架构设计，稍后再展开说我的看法。</p><h3 id="Flux-架构有什么不为人知的坑吗？我们就像看人黑-Flux！"><a href="#Flux-架构有什么不为人知的坑吗？我们就像看人黑-Flux！" class="headerlink" title="Flux 架构有什么不为人知的坑吗？我们就像看人黑 Flux！"></a>Flux 架构有什么不为人知的坑吗？我们就像看人黑 Flux！</h3><p>(咳咳咳~~~ 这个问题我得谨慎回答)</p><p>我觉得 Flux 架构没有把一个事实告诉大家，就是它的 Store 是中心化的，Flux 用中心化的 Store 取代了它吐槽的中心化的 Controller。</p><p>我看了一些基于 Flux/Redux/Vuex 架构的实现，基本上多个 Store 之间完全解耦不建立任何联系是不可能的——除非它们完全从数据行为各方面都是解耦的——这种程序用什么架构都无所谓的坦白讲。</p><p>为什么中心化的 Store 无人吐槽呢？因为中心化的数据复杂度绝对低于中心化的行为控制。你甚至没有意识到它是中心化的，这其实从另外一个侧面就证实了这一点。</p><p>所以我觉得透过 Flux 看架构的本质：这里不算是坑或吐槽，我更想说的是，放下 Flux 这把锤子，我们该怎么看世界，怎么看待自己每天在设计和架构的软件。</p><ol><li>中心化管理数据，避免数据孤立，一旦数据被孤立，就需要通过其它程序做串联，导致复杂。这是避免各路行为乱改数据导致混乱的一个潜在条件，或者说这是一个结论。</li><li>把行为做个归纳，抽象度提高，不管是用户操作导致的，还是从服务器 pull 过来的，还是系统本身操作的。</li><li>把修改数据的操作做个归纳，颗粒度变大，大到纯粹“无状态”的极限。</li><li>另外一个没有被过多谈论的细节，就是从 Model 到 View 要简单直接，这一点各路架构都是有共识的，就不多说了。</li></ol><p>在这几个方面，如果一个架构师能够做到极致，去TM的各种架构缩写，用哪个都一样。</p><h3 id="Vuex-怎么样？"><a href="#Vuex-怎么样？" class="headerlink" title="Vuex 怎么样？"></a>Vuex 怎么样？</h3><p>我先说我觉得 Vue.js 怎么样，Vue.js 天生做了几件事：</p><ol><li>components，即组件化，把视图分解开</li><li>通过 computed options 简化 data 到 template 的对应关系</li><li>通过 methods options 明确各路行为的抽象</li><li>通过双向 computed options 增大了对 data 操作的颗粒度</li><li>部分 methods options 也可以用来完成纯粹的 data 操作，增大对 data 操作的颗粒度</li></ol><p>所以 Vue.js 本身已经提供了很多很好的架构实践。但这在 Flux 看来还不够纯粹，它缺 2 点：</p><ol><li>数据有 components 之间的树形关联，但是修改起来是分散的</li><li>相应的 computed、methods 也应该不是分散的，需要改造</li></ol><p>所以 Vuex 需要做的事情很简单：</p><ol><li>中心化的 store，所有 components 都共用一份数据，即一份 state；更复杂的情况下，定义有限的几种 getters，用在 computed options 中</li><li>定义有限的几种 mutations (类比从 Dispatcher 到 Store 的约定)，可以直接用在 methods options 中；更复杂情况下，定义有限的几种 actions (类比从各路行为到 Dispatcher 的约定)，用在 methods options 中，背后调用的是各种定义好的 mutations。</li></ol><p>这样在 Vue 的基础上，再加上如虎添翼的 Vuex，开发者就可以享受到类似 Flux 的感觉了。</p><h3 id="都快说完了都没提“单向数据流”这个词"><a href="#都快说完了都没提“单向数据流”这个词" class="headerlink" title="都快说完了都没提“单向数据流”这个词"></a>都快说完了都没提“单向数据流”这个词</h3><p>是的，我觉得这是一个被用烂的词，以至于很多人在求职面试的时候一被问到 Flux 就脱口而出“单向数据流”，几乎当做 Flux 这个词的中文翻译在回答。就好像一说到 Scrum 就脱口而出“看板”一样……</p><p>我觉得单向数据流的讲法太过表面，不足够体现出 Flux 的设想和用意。现在一提单向数据流，我脑中第一个浮现的画面其实是这个：</p><p><img src="http://img1.tbcdn.cn/L1/461/1/3b6454f7043a339f958f06f9dcc77af000286075" alt="image_jpeg" title="image_jpeg"></p><h3 id="都快说完了都没提“时空穿梭-time-travel-”这个词"><a href="#都快说完了都没提“时空穿梭-time-travel-”这个词" class="headerlink" title="都快说完了都没提“时空穿梭 (time travel)”这个词"></a>都快说完了都没提“时空穿梭 (time travel)”这个词</h3><p>这是数据操作颗粒度变大之后的名词。我觉得它只是个名词，为什么这样说？</p><p>所为“时空穿梭”，本质就是记录下每一次数据修改，只要每次修改都是无状态的，那么我们理论上就可以通过修改记录还原之前任意时刻的数据。</p><p>大家设想一下，其实我们每次对数据最小颗粒度的、不能再分解的、最直接的操作基本 (比如赋值、删除、增减数据项目等) 都是无状态的，其实我们如果写个简单的程序，把每次直接修改数据的操作记录下来，同样可以很精细的进行“时空穿梭”，但没有人提这个词，因为它颗粒度太细了，没有语义，没有人愿意在这样琐碎的数据操作中提炼“时空”。因为数据操作的颗粒度变大了，所以变得直观，有语义，易于理解，对我们的功能研发和调试有实际帮助，所以才有了“时空穿梭”这个概念。</p><h3 id="Weex-什么时候支持-Flux-Vuex？"><a href="#Weex-什么时候支持-Flux-Vuex？" class="headerlink" title="Weex 什么时候支持 Flux/Vuex？"></a>Weex 什么时候支持 Flux/Vuex？</h3><p>这是我最后想说的，首先不管有没有 Flux/Vuex，一个好的架构实践已经足以满足日常的研发需求，尤其是在手机上，界面、数据和行为都不会特别复杂。</p><p>其次，如果基于 Vue 2.0 来开发 Weex 页面或应用的话，Vuex 是天生支持的，不需要额外做什么。大家如果已经在浏览器中，不论是桌面还是手机上实践过 Vuex，应该是感觉不到任何不一样的。</p><p>最后，上周我简单写了个 Vuex 的复刻版，能够在 Weex 的 JS Framework 上工作，这里不想占太多篇幅介绍。坦白讲我希望大家更多的精力在理解 Flux 和 Vue 上。其它问题都是顺理成章的。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这篇文章整理了我个人对 Flux 的理解和个人看法，首先解释一下 Flux 核心的四个名词：View, Store, Action, Dispatcher，然后提出 Dispatcher 在 Flux 架构中的关键位置，并解释为什么 Dispatcher 让其他三者变得更好更“正规”，然后是一些我通过了解 Flux 认识到的背后倡导的架构设计的最佳实践的提炼。</p><p>真的没有代码……</p><p>……好吧如果一定要看代码可以看看这里</p><ul><li><a href="https://github.com/reactjs/redux">https://github.com/reactjs/redux</a></li><li><a href="https://github.com/vuejs/vuex">https://github.com/vuejs/vuex</a></li><li><a href="https://github.com/Jinjiang/weex-x">https://github.com/Jinjiang/weex-x</a></li></ul><p>谢谢</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;mark&gt;本文早些时候发表在 云栖社区 &lt;a href=&quot;https://yq.aliyun.com/articles/59357&quot;&gt;https://yq.aliyun.com/articles/59357&lt;/a&gt;&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;之前 review 业务代码
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【整理】Vue 2.0 自 beta 1 到 beta 4 以来的主要更新</title>
    <link href="https://jiongks.name//blog/vue-2-from-beta-1-to-beta-4/"/>
    <id>https://jiongks.name//blog/vue-2-from-beta-1-to-beta-4/</id>
    <published>2016-07-28T05:33:05.000Z</published>
    <updated>2017-08-01T03:01:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>主要内容来自 <a href="https://github.com/vuejs/vue/releases">https://github.com/vuejs/vue/releases</a></p><p>之前 <a href="https://jiongks.name/blog/announcing-vue-2/">Vue 2.0 发布技术预览版</a> 到现在差不多三个月了，之前写过一篇简单的 <a href="https://jiongks.name/blog/code-review-for-vue-next/">code review</a>，如今三个月过去了，Vue 2.0 在这个<a href="https://jiongks.name/blog/a-big-map-to-intro-vue-next/">基础</a>之上又带来了不少更新，这里汇总 beta 以来 (最新的版本是 beta 4) 的主要更新，大家随意学习感受一下</p><h3 id="alpha-和-beta-版本的侧重点会有所不同"><a href="#alpha-和-beta-版本的侧重点会有所不同" class="headerlink" title="alpha 和 beta 版本的侧重点会有所不同"></a>alpha 和 beta 版本的侧重点会有所不同</h3><p>首先 Vue 2.0 对 alpha、beta 有自己的理解和设定：alpha 版本旨在完善 API、考虑所需的特性；而来到 beta 版则会对未来的正式发布进行充分的“消化”，比如提前进行一些必要的 breaking change，增强框架的稳定性、完善文档和周边工具 (如 vue-router 2.0 等)</p><h3 id="最后的几个-alpha-版本主要更新"><a href="#最后的几个-alpha-版本主要更新" class="headerlink" title="最后的几个 alpha 版本主要更新"></a>最后的几个 alpha 版本主要更新</h3><p>Vue 本身的语法基础这里就不多赘述了，网上有很多资料可以查阅，我们已经假定你比较熟悉 Vue 并对 2.0 的理念和技术预览版的状态有一定的了解。</p><a id="more"></a><h4 id="alpha-5"><a href="#alpha-5" class="headerlink" title="alpha 5"></a>alpha 5</h4><ol><li>ref 的写法由 <code>&lt;comp v-ref:foo&gt;</code> 变成了 <code>&lt;comp ref=&quot;foo&quot;&gt;</code>，更加简单，同时动态数据的写法是 <code>&lt;comp :ref=&quot;x&quot;&gt;</code></li><li><p>支持 functional components，这个特性蛮酷的，可以把一个组件的生成过程完全变成一个高度自定义的函数执行过程，比如：</p><p> Vue.component(‘name’, {</p><pre><code>functional: true,props: [&apos;x&apos;],render: (h, props, children) &#123;    return h(props.tag, null, children)&#125;</code></pre><p> })</p></li></ol><p>你可以在 <code>render()</code> 函数里写各种特殊的逻辑，这样标签的含义和能力都得到了非常大的扩展，在后续的几次更新中，你马上会感受到一些 functional components 的威力</p><p>另外剧透一下，<code>h</code> 方法里的第二个参数如果是 <code>null</code> 就可以省略，这个改动出现在了 beta 1</p><h4 id="alpha-6"><a href="#alpha-6" class="headerlink" title="alpha 6"></a>alpha 6</h4><p>可以设置特殊的 keyCode，比如 <code>Vue.config.keyCodes.a = 65</code>，然后你就可以写 <code>&lt;input @keyup.a=&quot;aPressed&quot;&gt;</code> 了</p><h4 id="alpha7"><a href="#alpha7" class="headerlink" title="alpha7"></a>alpha7</h4><ol><li>一个组件的生命周期名由 <code>init</code> 改成了 <code>beforeCreated</code> (大家可以在 Vuex 的源码里看到对应的改变哦)</li><li><code>Vue.transition</code> 的 hook 支持第二个参数，把 vm 传递进去</li></ol><p>如：</p><pre><code>Vue.transition(&apos;name&apos;, &#123;    onEnter (el, vm) &#123;        ...    &#125;&#125;)</code></pre><h3 id="Beta-1-Beta-4"><a href="#Beta-1-Beta-4" class="headerlink" title="Beta 1 ~ Beta 4"></a>Beta 1 ~ Beta 4</h3><h4 id="beta-1"><a href="#beta-1" class="headerlink" title="beta 1"></a>beta 1</h4><ol><li>自定义 directive 里 <code>update</code> 的触发时机发生了变化，由于 functional component 等概念的引入，一个 directive 的变更的颗粒度也不完全是 directive 本身引起的，所以这里做了一个更具有通用性的调整；同时 hook 名 <code>postupdate</code> 也相应的更名为 <code>componentUpdated</code>——如果你想让 <code>update</code> 保持原有的触发时机，可以加入一句 <code>binding.value !== binding.oldValue</code> 即可。</li><li><code>Vue.traisition</code> 的 hook 名做了简化<ul><li><code>onEnter</code> -&gt; <code>enter</code></li><li><code>onLeave</code> -&gt; <code>leave</code></li></ul></li><li>server-side rendering<ul><li><code>server.getCacheKey</code> 更名为 <code>serverCacheKey</code>，避免多一层结构嵌套</li><li><code>createRenderer</code>/<code>createBundleRenderer</code> 方法不会强制应用 <code>lru-cache</code>，而是开发者手动选择</li></ul></li></ol><h4 id="beta-2"><a href="#beta-2" class="headerlink" title="beta 2"></a>beta 2</h4><p><code>&lt;transition&gt;</code> 标签来了！</p><p>其实这个玩意儿我之前在 polymer 等其他框架里也见到过，不过看到 Vue 的语法设计，还是觉得巧妙而简洁：</p><pre><code>&lt;transition&gt;    &lt;div v-if=&quot;...&quot;&gt;...&lt;/div&gt;&lt;/traisition&gt;&lt;transition-group tag=&quot;ul&quot;&gt;    &lt;li v-for=&quot;...&quot;&gt;...&lt;/li&gt;&lt;/traisition-group&gt;</code></pre><p>更牛掰的在这里，还记得 functional components 吧，你今天可以这样抽象一个动画效果的标签：</p><pre><code>Vue.component(&apos;fade&apos;, &#123;    functional: true,    render (h, children) &#123;        return h(&apos;transition&apos;, &#123;            props: &#123;...&#125;,            on: &#123;                beforeEnter,                afterEnter            &#125;        &#125;, children)    &#125;&#125;)</code></pre><p>然后</p><pre><code>&lt;fade&gt;...&lt;/fade&gt;</code></pre><p>就可以实现高度自定义的动画效果了，这个我个人觉得是非常赞的设计和实现！</p><h4 id="beta-3"><a href="#beta-3" class="headerlink" title="beta 3"></a>beta 3</h4><ol><li>支持在自定义组件中使用原生事件。因为在 Vue 2.0 的设计中，自定义组件上是不能绑定原生事件的，自定义组件上的事件绑定被默认理解为组件的自定义事件，而不是原生事件。针对这个问题我很早就提了 <a href="https://github.com/vuejs/vue/issues/2942">issue</a> 当时小右提出了一个新的语法设计，就是 <code>&lt;comp @click.native=&quot;...&quot;&gt;&lt;/comp&gt;</code>，beta 3 的时候终于看到它被实现了，嘿嘿，有点小激动</li><li>支持两种语法 <code>&lt;div :xxx.prop=&quot;x&quot;&gt;</code> 和 <code>&lt;div v-bind:prop=&quot;&#123; xxx: x &#125;&quot;&gt;</code> 来对 DOM 的 property 进行绑定，最近我自己也在思考一些在 virtual-DOM 上支持 properties 而不只是 attributes 的想法，这个设计让我也多了一些新的思路。</li></ol><h4 id="beta-4"><a href="#beta-4" class="headerlink" title="beta 4"></a>beta 4</h4><p>2 天前发布的，其实这个版本以 bugfix 为主</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上是近期 Vue 2.0 的一些更新，让我自己比较兴奋的主要是 functional component 以及基于这个设计的 <code>&lt;transition&gt;</code> 和 <code>&lt;transition-group&gt;</code> 标签和自定义 transition 标签的能力拓展，还有就是久违的 <code>&lt;comp @click.native=&quot;...&quot;&gt;&lt;/comp&gt;</code></p><p>最后希望大家可以多多试用，有更大兴趣的可以多多学习 Vue 的源码！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要内容来自 &lt;a href=&quot;https://github.com/vuejs/vue/releases&quot;&gt;https://github.com/vuejs/vue/releases&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;之前 &lt;a href=&quot;https://jiongks.name/blog/announcing-vue-2/&quot;&gt;Vue 2.0 发布技术预览版&lt;/a&gt; 到现在差不多三个月了，之前写过一篇简单的 &lt;a href=&quot;https://jiongks.name/blog/code-review-for-vue-next/&quot;&gt;code review&lt;/a&gt;，如今三个月过去了，Vue 2.0 在这个&lt;a href=&quot;https://jiongks.name/blog/a-big-map-to-intro-vue-next/&quot;&gt;基础&lt;/a&gt;之上又带来了不少更新，这里汇总 beta 以来 (最新的版本是 beta 4) 的主要更新，大家随意学习感受一下&lt;/p&gt;
&lt;h3 id=&quot;alpha-和-beta-版本的侧重点会有所不同&quot;&gt;&lt;a href=&quot;#alpha-和-beta-版本的侧重点会有所不同&quot; class=&quot;headerlink&quot; title=&quot;alpha 和 beta 版本的侧重点会有所不同&quot;&gt;&lt;/a&gt;alpha 和 beta 版本的侧重点会有所不同&lt;/h3&gt;&lt;p&gt;首先 Vue 2.0 对 alpha、beta 有自己的理解和设定：alpha 版本旨在完善 API、考虑所需的特性；而来到 beta 版则会对未来的正式发布进行充分的“消化”，比如提前进行一些必要的 breaking change，增强框架的稳定性、完善文档和周边工具 (如 vue-router 2.0 等)&lt;/p&gt;
&lt;h3 id=&quot;最后的几个-alpha-版本主要更新&quot;&gt;&lt;a href=&quot;#最后的几个-alpha-版本主要更新&quot; class=&quot;headerlink&quot; title=&quot;最后的几个 alpha 版本主要更新&quot;&gt;&lt;/a&gt;最后的几个 alpha 版本主要更新&lt;/h3&gt;&lt;p&gt;Vue 本身的语法基础这里就不多赘述了，网上有很多资料可以查阅，我们已经假定你比较熟悉 Vue 并对 2.0 的理念和技术预览版的状态有一定的了解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vue" scheme="https://jiongks.name/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>通过一张图走进 Vue 2.0</title>
    <link href="https://jiongks.name//blog/a-big-map-to-intro-vue-next/"/>
    <id>https://jiongks.name//blog/a-big-map-to-intro-vue-next/</id>
    <published>2016-05-12T08:47:39.000Z</published>
    <updated>2016-05-12T08:47:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>这可能是字最少的一篇了，都在图里 - -</p><p>文字介绍稍后抽空再补补</p><p><a href="https://ww2.sinaimg.cn/large/660d0cdfgw1f3sv9xpn3vj21221yrdp8.jpg"><img src="https://ww2.sinaimg.cn/large/660d0cdfgw1f3sv9xpn3vj21221yrdp8.jpg" alt=""></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这可能是字最少的一篇了，都在图里 - -&lt;/p&gt;
&lt;p&gt;文字介绍稍后抽空再补补&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://ww2.sinaimg.cn/large/660d0cdfgw1f3sv9xpn3vj21221yrdp8.jpg&quot;&gt;&lt;img src=&quot;http
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Code Review for Vue 2.0 Preview</title>
    <link href="https://jiongks.name//blog/code-review-for-vue-next/"/>
    <id>https://jiongks.name//blog/code-review-for-vue-next/</id>
    <published>2016-04-28T01:16:03.000Z</published>
    <updated>2016-05-11T02:17:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>是的！<a href="https://jiongks.name/blog/announcing-vue-2/">Vue 2.0 发布了！</a> 源代码仓库<a href="https://github.com/vuejs/vue/tree/next">在此</a></p><p>首先，当我第一次看到 Vue 2.0 的真面目的时候，我的内心是非常激动的</p><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>来个简单的 demo，首先把 <code>dist/vue.js</code> 导入到一个空白的网页里，然后写：</p><p><strong>当然，在大家阅读下面所有的内容之前，先想象一下，这是一个运行时 min+gzip 后只有 12kb 大小的库</strong></p><pre><code>&lt;script src=&quot;./dist/vue.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;app&quot;&gt;  Hello &#123;&#123;who&#125;&#125;&lt;/div&gt;&lt;script&gt;  new Vue(&#123;    el: &apos;#app&apos;,    data: &#123;who: &apos;Vue&apos;&#125;  &#125;)&lt;/script&gt;</code></pre><p>你将看到 “Hello Vue”</p><p>然后再看一个神奇的：</p><pre><code>&lt;script src=&quot;./dist/vue.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;script&gt;  new Vue(&#123;    el: &apos;#app&apos;,    render: function () &#123;      with (this) &#123;        __h__(&apos;div&apos;,          &#123;staticAttrs:&#123;&quot;id&quot;:&quot;app&quot;&#125;&#125;,          [(&quot;\n  Hello &quot;+__toString__(who)+&quot;\n&quot;)],          &apos;&apos;        )      &#125;    &#125;    data: &#123;who: &apos;Vue&apos;&#125;  &#125;)&lt;/script&gt;</code></pre><p>这个是 compile 过后的格式，大家会发现首先 <code>#app</code> 下不需要写模板了，然后 <code>&lt;script&gt;</code> 里多了一个 <code>render</code> 字段，Vue 在运行时其实是会把模板内容先转换成渲染方法存入 <code>render</code> 字段，然后再执行，如果发现 <code>render</code> 已经存在，就跳过模板解析过程直接渲染。所以在 Vue 2.0 中写一段模板和写一个 <code>render</code> option 是等价的。为什么要这样设计，稍后会我们会涉及到。</p><a id="more"></a><h3 id="Code-Review"><a href="#Code-Review" class="headerlink" title="Code Review"></a>Code Review</h3><p>废话不说，来看<a href="https://github.com/vuejs/vue/tree/next">仓库</a></p><p>哎呀好东西太多我都不知道该先讲哪个啦！</p><h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json - -"></a><code>package.json</code> - -</h3><p><a href="https://github.com/vuejs/vue/blob/next/package.json">https://github.com/vuejs/vue/blob/next/package.json</a></p><p>先看这里，我个人习惯是拿到仓库之后除了 README (它没写) 就先看这个。和 1.x 相比，开发工具链还是以 rollup + webpack + karma 为主，开发的时候用 webpack 加 watch；打包的时候用 rollup 快速而且可以自动删掉没用到的代码片段；测试的时候用 karma 各种组合，包括 e2e、spec、coverage、sauce等。语法检查用了 eslint 这个似乎没什么争议和悬念。另外我发现了两个新东西：<a href="http://nightwatchjs.org/">nightwatch</a> 和 <a href="https://www.npmjs.com/package/selenium-server">selenium-server</a></p><p>另外你们就选眼睛再迟钝也会看到 ssr 这个词吧！对，就是服务端渲染 Server-Side Rendering！先不急，这个最后说，你们可以先去 high 一会儿</p><h3 id="src"><a href="#src" class="headerlink" title="src"></a><code>src</code></h3><p>作为一个见证了一小段 Vue 2.0 成长过程的脑残粉，我得跟大家从时间线的角度介绍一下这个文件夹：</p><h4 id="compiler-runtime"><a href="#compiler-runtime" class="headerlink" title="compiler + runtime"></a><code>compiler</code> + <code>runtime</code></h4><p>早些时候 Vue 2.0 的代码还是这样分的，一半运行时，一半(预)编译时，中间会通过一个 JavaScript 的格式严格划清界限，即源代码 template + JavaScript 经过编译之后变成了一段纯 JavaScript 代码，然后这段纯 JavaScript 的代码又可以在运行时被执行渲染。</p><p>这里面奇妙的地方是：编译时的代码完全可以脱离浏览器预执行，也可以在浏览器里执行。所以你可以把代码提前编译好，减轻运行时的负担。</p><p>由于 Vue 2.0 对 template 的解析没有借助 DOM 以及 fragment document，而是在 John Resig 的 <a href="https://github.com/vuejs/vue/blob/14feb83879fe32fc9c54eddf33c6c5ef2fb4e8a2/src/compiler/parser/html-parser.js">HTML Parser</a> 基础上实现的，所以完全可以在任何主流的 JavaScript 环境中执行，这也为 ssr 提供了必要的基础</p><p>Vue 最早会打包生成三个文件，一个是 runtime only 的文件 vue.common.js，一个是 compiler only 的文件 compiler.js，一个是 runtime + compiler 的文件 vue.js，它们有三个打包入口，都放在了 <code>entries</code> 目录下，这是 <code>src</code> 里的第三个文件夹，第四个文件夹是 <code>shared</code>，放置一些运行时和编译时都会用到的工具方法集。</p><h4 id="compiler-runtime-platforms"><a href="#compiler-runtime-platforms" class="headerlink" title="compiler + runtime + platforms"></a><code>compiler</code> + <code>runtime</code> + <code>platforms</code></h4><p>Wahahaha~</p><p>这要说到 Vue 2.0 的第二个优点：virtual-DOM！virtual-DOM 有很多优点，也被很多人热议，而 Vue 2.0 里面的 virtual-DOM 简直是把它做到了极致！代码非常简练，而且性能超高 (据说秒杀 React，我自己没试过，大家可以自己比比看)。在这一点上编译器的前置起到了非常重要的作用，而且很多 diff 算法的优化点而且是在运行时之前就准备好的。</p><p>另外 virtual-DOM 的另一个优点当然就是可以对渲染引擎做一般化的抽象，进而适配到更多类型的终端渲染引擎上！所以在我的怂恿下，小右把本来在 <code>runtime</code> 下的 <code>runtime/dom</code> 文件夹挪到了一个名叫 <code>platforms</code> 的新文件夹下，改名叫 <code>platforms/web/runtime</code>，把本来 <code>compiler</code> 文件夹下 web 相关的 <code>modules</code> 挪到了 <code>platforms/web/compiler</code>！</p><p>(是的没错，今天在 <a href="https://alibaba.github.io/weex/">Weex</a> 的子仓库里已经有另外一个 <code>platforms/weex</code> 文件夹了耶)</p><h4 id="compiler-runtime-platforms-server"><a href="#compiler-runtime-platforms-server" class="headerlink" title="compiler + runtime + platforms + server"></a><code>compiler</code> + <code>runtime</code> + <code>platforms</code> + <code>server</code></h4><p>是的没有错！Vue 2.0 既然已经有了 virtual-DOM，也有了运行环境无关的 compiler，为什么不能 ssr 呢？！Vue 2.0 不只是简单的把预渲染拿到服务端这么简单，Vue 2.0 ssr 除了提供传统的由源文件编译出字符串之外，还提供了输出 stream 的功能，这样服务端的渲染不会因为大量的同步字符串处理而变慢。即：<code>createRenderer()</code> 会返回 <code>renderToString()</code> 和 <code>renderToStream()</code> 两个方法。同时，在 <code>platforms/web</code> 文件夹下除了 <code>runtime</code> 和 <code>compiler</code> 之外又多了一个 <code>server</code> 目录，这样编译器、服务端流式预渲染、运行时的铁三角架构就这样达成了！</p><h3 id="test"><a href="#test" class="headerlink" title="test"></a><code>test</code></h3><p>说到测试，我惊奇的发现，在带来了这么多颠覆性的改变之后，Vue 2.0 竟然完好保留了绝大多数 1.0 的 API 设计，而且更快更小巧延展性更强。Vue 2.0 在前期研发阶段主要是通过粗线条的 e2e 测试进行质量保障的，因为版本延续性做得非常好，所以这部分在 1.x 的积累已经帮上很大忙了。现在 Vue 2.0 逐渐的在从 feature 的角度在进一步覆盖测试用例，对每个 API 和每个流程进行测试。目前以我个人的感觉主要的常见的链路都已经比较畅通了，具体功能细节上偶尔还是会遇到 bug 待修复，不过作为一个新兴的 Vue 2.0 来说，相信这已经远远超过大家的预期了！</p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>我觉得 Vue 2.0 在编译器和运行时的解耦上做得超级棒！中间格式设计得也非常巧妙，把静态的部分在编译时就分析出来，而且通过非常简单的 <code>__h__</code>, <code>__renderList__</code> 等方法就搞定了几乎所有的逻辑控制和数据绑定。之前我个人在实践 Weex 的时候也是会把 template 提前 compile，但只是 compile 成一段 JSON，逻辑分析还是在运行时做的，当时和小右交流的时候就在讨论，能不能把分析过程也前置，无奈自己功力不够啊，一直没搞出来。看到 2.0 横空出世，简直是泪流满面有木有！！</p><p>还有一件事情也是之前跟小右聊到过，就是目前 Vue 提供的很多 directive 包括 filter 也都是有机会前置处理的，所以在 Vue 2.0 里，有相当一部分 directive 是前置处理成一般格式的，运行时只是针对各端的渲染机制保留了 attr, style, class, event 等几个最基础简单的解析过程，比如 if, for, else 都直接在 compile 的时候被解开了。而且 Vue 2.0 把这部分内容抽象得如此清晰，除了赞叹还是赞叹！！</p><p>还有就是，你们去看看 Vue 2.0 的提交记录，300+ 次提交，上万行高效优质的代码，总共花了差不多两周的时间，而且提交时间几乎遍布二十四个小时……</p><p>别的不多啰嗦了，我觉得大家还是亲自看过 Vue 2.0 的源码，会对这些内容有更深刻的了解。从今天起，fork + clone Vue 2.0，写写 demo、写写测试、练练英文 XD go!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;是的！&lt;a href=&quot;https://jiongks.name/blog/announcing-vue-2/&quot;&gt;Vue 2.0 发布了！&lt;/a&gt; 源代码仓库&lt;a href=&quot;https://github.com/vuejs/vue/tree/next&quot;&gt;在此&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先，当我第一次看到 Vue 2.0 的真面目的时候，我的内心是非常激动的&lt;/p&gt;
&lt;h3 id=&quot;Demo&quot;&gt;&lt;a href=&quot;#Demo&quot; class=&quot;headerlink&quot; title=&quot;Demo&quot;&gt;&lt;/a&gt;Demo&lt;/h3&gt;&lt;p&gt;来个简单的 demo，首先把 &lt;code&gt;dist/vue.js&lt;/code&gt; 导入到一个空白的网页里，然后写：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当然，在大家阅读下面所有的内容之前，先想象一下，这是一个运行时 min+gzip 后只有 12kb 大小的库&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&amp;quot;./dist/vue.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;

&amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;
  Hello &amp;#123;&amp;#123;who&amp;#125;&amp;#125;
&amp;lt;/div&amp;gt;
&amp;lt;script&amp;gt;
  new Vue(&amp;#123;
    el: &amp;apos;#app&amp;apos;,
    data: &amp;#123;who: &amp;apos;Vue&amp;apos;&amp;#125;
  &amp;#125;)
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你将看到 “Hello Vue”&lt;/p&gt;
&lt;p&gt;然后再看一个神奇的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&amp;quot;./dist/vue.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;

&amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;script&amp;gt;
  new Vue(&amp;#123;
    el: &amp;apos;#app&amp;apos;,
    render: function () &amp;#123;
      with (this) &amp;#123;
        __h__(&amp;apos;div&amp;apos;,
          &amp;#123;staticAttrs:&amp;#123;&amp;quot;id&amp;quot;:&amp;quot;app&amp;quot;&amp;#125;&amp;#125;,
          [(&amp;quot;\n  Hello &amp;quot;+__toString__(who)+&amp;quot;\n&amp;quot;)],
          &amp;apos;&amp;apos;
        )
      &amp;#125;
    &amp;#125;
    data: &amp;#123;who: &amp;apos;Vue&amp;apos;&amp;#125;
  &amp;#125;)
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个是 compile 过后的格式，大家会发现首先 &lt;code&gt;#app&lt;/code&gt; 下不需要写模板了，然后 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 里多了一个 &lt;code&gt;render&lt;/code&gt; 字段，Vue 在运行时其实是会把模板内容先转换成渲染方法存入 &lt;code&gt;render&lt;/code&gt; 字段，然后再执行，如果发现 &lt;code&gt;render&lt;/code&gt; 已经存在，就跳过模板解析过程直接渲染。所以在 Vue 2.0 中写一段模板和写一个 &lt;code&gt;render&lt;/code&gt; option 是等价的。为什么要这样设计，稍后会我们会涉及到。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
